-- phpMyAdmin SQL Dump
-- version 4.4.15.10
-- https://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: 2020-07-06 01:25:37
-- 服务器版本： 5.6.46-log
-- PHP Version: 5.6.40

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `react-blog`
--

-- --------------------------------------------------------

--
-- 表的结构 `artcomment`
--

CREATE TABLE IF NOT EXISTS `artcomment` (
  `id` int(11) NOT NULL,
  `art_id` int(11) NOT NULL,
  `com_name` varchar(255) NOT NULL DEFAULT '',
  `comment` text NOT NULL,
  `add_time` int(11) NOT NULL DEFAULT '0',
  `is_reply` int(11) DEFAULT '0',
  `reply_id` varchar(255) DEFAULT '',
  `art_title` varchar(255) NOT NULL DEFAULT ''
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `artcomment`
--

INSERT INTO `artcomment` (`id`, `art_id`, `com_name`, `comment`, `add_time`, `is_reply`, `reply_id`, `art_title`) VALUES
(28, 19, '测试', '测试', 1586782812, 0, '', 'JS-抖音很火的文字时钟'),
(29, 19, '测试2', '测试2', 1586782828, 1, '28', 'JS-抖音很火的文字时钟'),
(30, 15, '测试', '测试', 1586851212, 0, '', '微信小程序开发遇到的那些坑'),
(31, 15, '测试', '测试', 1586851226, 1, '30', '微信小程序开发遇到的那些坑'),
(34, 13, '哈哈', 'test', 1588519140, 0, '', 'Markdown语法'),
(35, 20, 'test12', '开心', 1589529378, 0, '', '常用技术-学习网站'),
(36, 20, 'test1', '哈哈', 1589529392, 1, '35', '常用技术-学习网站'),
(37, 19, 'haha', 'haha', 1589531437, 0, '', 'JS-抖音很火的文字时钟'),
(38, 19, '嘻嘻', 'xixi', 1589531530, 1, '37', 'JS-抖音很火的文字时钟'),
(39, 16, '嘻嘻', '欧里给', 1590027270, 0, '', 'JS封装方法总结'),
(40, 38, '哈哈', '嘻嘻', 1590171903, 0, '', '手撕“穷人版VUE“'),
(41, 44, 'zy', '啦啦啦啦啦啦', 1591760631, 0, '', 'React实现自定义蒙层'),
(42, 44, 'wz', '嘻嘻嘻嘻嘻', 1593967644, 1, '41', 'React实现自定义蒙层'),
(43, 44, 'xr', '哈哈啊', 1593967895, 0, '', 'React实现自定义蒙层'),
(44, 44, 'wz', '哈哈啊哈', 1593968036, 1, '43', 'React实现自定义蒙层');

-- --------------------------------------------------------

--
-- 表的结构 `article`
--

CREATE TABLE IF NOT EXISTS `article` (
  `Id` int(11) NOT NULL,
  `type_id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `article_content` text NOT NULL,
  `introduce` text,
  `addTime` int(11) DEFAULT NULL,
  `view_count` int(255) NOT NULL,
  `isTop` tinyint(255) NOT NULL
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `article`
--

INSERT INTO `article` (`Id`, `type_id`, `title`, `article_content`, `introduce`, `addTime`, `view_count`, `isTop`) VALUES
(13, 1, 'Markdown语法', '<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=430 height=70\nsrc="//music.163.com/outchain/player?type=2&rel=0&amp&id=114389&auto=1&height=66" allow="autoplay"></iframe>\n\n# P01 Markdown 简介\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 <kbd>.md</kbd>或<kbd>.markdown</kbd>。</p>\n\n# P02 Markdown 标题\n\n<p>Markdown 标题有两种格式。</p>\n\n> 1.使用 = 和 - 标记一级和二级标题\n\n```\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n-----------------\n```\n\n## 我展示的是二级标题\n\n> 2.使用 # 号标记\n\n<p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>\n\n## 二级标题\n### 三级标题\n\n# P03 Markdown 段落\n\n<p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p>\n\n## 字体\n\nMarkdown 可以使用以下几种字体\n\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n显示效果如下所示：\n\n_斜体文本_\n_斜体文本_\n**粗体文本**\n**粗体文本**\n**_粗斜体文本_**\n**_粗斜体文本_**\n\n## 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n```\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n```\n\n---\n\n---\n\n---\n\n---\n\n---\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n```\n~~BAIDU.COM~~\n```\n\n~~BAIDU.COM~~\n\n## 下划线\n\n下划线可以通过 HTML 的 `<u>` 标签来实现：\n\n```\n<u>带下划线文本</u>\n```\n\n<u>带下划线文本</u>\n\n## 脚注\n\n脚注是对文本的补充说明。\n\n```\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n```\n\n创建脚注格式类似这样 [^runoob]。\n\n[^runoob]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n\n# P04 Markdown 列表\n\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号(\\*)、加号(+)或是减号(-)作为列表标记：\n\n```\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n- 第一项\n- 第二项\n- 第三项\n\n* 第一项\n* 第二项\n* 第三项\n\n- 第一项\n- 第二项\n- 第三项\n\n有序列表使用数字并加上 . 号来表示，如\n\n```\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n1. 第一项\n2. 第二项\n3. 第三项\n\n## 列表嵌套\n\n```\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n1. 第一项：\n   - 第一项嵌套的第一个元素\n   - 第一项嵌套的第二个元素\n2. 第二项：\n   - 第二项嵌套的第一个元素\n   - 第二项嵌套的第二个元素\n\n# P05 Markdown 区块\n\nMarkdown 区块引用是在段落开头使用 `>` 符号 ，然后后面紧跟一个空格符号：\n\n```\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n```\n\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n\n另外区块是可以嵌套的，一个 `>` 符号是最外层，两个 `>` 符号是第一层嵌套，以此类推：\n\n```\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n> 最外层\n>\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n\n## 区块中使用列表\n\n区块中使用列表实例如下：\n\n```\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n> 区块中使用列表\n>\n> 1. 第一项\n> 2. 第二项\n>\n> - 第一项\n> - 第二项\n> - 第三项\n\n## 列表中使用区块\n\n如果要在列表项目内放进区块，那么就需要在 `>` 前添加四个空格的缩进。\n\n区块中使用列表实例如下：\n\n```\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n- 第一项\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n- 第二项\n\n# P06 Markdown 代码\n\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来<kbd>`</kbd>，例如：\n\n```\n`printf()` 函数\n```\n\n`printf()` 函数\n\n## 代码区块\n\n代码区块使用 4 个空格或者一个制表符（Tab 键）\n\n```\n    $(document).ready(function () {\n    alert(''RUNOOB'');\n    });\n```\n\n    $(document).ready(function () {\n    alert(''RUNOOB'');\n    });\n\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n\n````\n```javascript\n$(document).ready(function () {\n    alert(''RUNOOB'');\n});\n```\n````\n\n\n```javascript\n$(document).ready(function () {\n    alert(''RUNOOB'');\n});\n```\n\n# P07 Markdown 链接\n\n链接使用方法如下：\n```\n[链接名称](链接地址)\n或者\n<链接地址>\n```\n\n例如：\n```\n这是一个链接 [菜鸟教程](https://www.runoob.com)\n```\n显示结果如下：\n\n这是一个链接 [菜鸟教程](https://www.runoob.com)\n\n\n\n>直接使用链接地址：\n```\n<https://www.runoob.com>\n```\n<https://www.runoob.com>\n\n## 高级链接\n```\n链接也可以用变量来代替，文档末尾附带变量地址：\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 runoob 作为网址变量 [Runoob][runoob]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [runoob]: http://www.runoob.com/\n```\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 runoob 作为网址变量 [Runoob][runoob]\n\n[1]: http://www.google.com/\n[runoob]: http://www.runoob.com/\n\n# P08 Markdown 图片\n\nMarkdown 图片语法格式如下：\n\n```\n![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 "可选标题")\n```\n>开头一个感叹号 !\n\n>接着一个方括号，里面放上图片的替代文字\n\n>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ''title'' 属性的文字。\n\n例：\n```\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png "RUNOOB")\n```\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png "RUNOOB")\n\n也可以像网址那样对图片网址使用变量:\n\n例：\n\n```\n这个链接用 1 作为网址变量 [RUNOOB][1].\n然后在文档的结尾为变量赋值（网址）\n\n[1]: http://static.runoob.com/images/runoob-logo.png\n```\n\n这个链接用 1 作为网址变量 [RUNOOB][2].\n\n[2]: http://static.runoob.com/images/runoob-logo.png\n\n>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 `img` 标签。、\n\n例：\n```\n<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">\n```\n<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">\n\n# P09 Markdown 表格\n\nMarkdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n\n```\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n>对齐方式\n\n我们可以设置表格的对齐方式：\n\n* -: 设置内容和标题栏居右对齐。\n* :- 设置内容和标题栏居左对齐。\n* :-: 设置内容和标题栏居中对齐。\n\n例：\n```\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n# P10 Markdown 高级技巧\n\n## 支持的 HTML 元素\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：`<kbd>` `<b>` `<i>` `<em>` `<sup>` `<sub>` `<br>`等\n\n如：\n\n```\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n## 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n\n例：\n```\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n# P11 视频\n```\n<video src="视频链接" controls="controls" width="500" height="300">您的浏览器不支持播放该视频！</video>\n```\n\n<video src="http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400" controls="controls" width="100%">您的浏览器不支持播放该视频！</video>\n\n<video src="https://v-cdn.zjol.com.cn/276985.mp4" controls="controls" width="100%">您的浏览器不支持播放该视频！</video>\n\n\n\n\n\n\n\n', 'Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写文档或是用于论坛上发表消息。例如：GitHub等等\n```\n链接也可以用变量来代替，文档末尾附带变量地址：\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 runoob 作为网址变量 [Runoob][runoob]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [runoob]: http://www.runoob.com/\n```\n', 1581436800, 94, 0),
(16, 1, 'JS封装方法总结', '# JS封装方法总结\n## 求滚动条滚动距离\n```\nfunction getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}\n```\n\n## 返回浏览器视口尺寸\n```\nfunction getViewportOffset() {\n    if (window.innerWidth) {\n        return {\n            w: window.innerWidth,\n            h: window.innerHeight\n        }\n    } else {\n        if (document.compatMode === "BackCompat") {\n            return {\n                w: document.body.clientWidth,\n                h: document.body.clientHeight\n            }\n        } else {\n            return {\n                w: document.documentElement.clientWidth,\n                h: document.documentElement.clientHeight\n            }\n        }\n    }\n}\n```\n## 获取元素样式(兼容)\n```\nfunction getStyle(elem, prop) {\n    if (window.getComputedStyle) {\n        return window.getComputedStyle(elem, null)[prop];\n    } else {\n        return elem.currentStyle[prop];\n    }\n}\n```\n\n## 给一个dom对象添加该事件类型的函数（兼容）\n```\nfunction addEvent(elem, type, handle) {\n    if (elem.addEventListener) {\n        elem.addEventListener(type, handle, false);\n    } else if (elem.attachEvent) {\n        elem.attachEvent(''on'' + type, function () {\n            handle.call(elem);\n        })\n    } else {\n        elem[''on'' + type] = handle;\n    }\n}\n```\n## 删除事件\n```\nfunction removeEvent(elem, type, handle) {\n    if (typeof elem.removeEventListener !== ''undefined'') {\n        elem.removeEventListener(type, handle, false);\n    } else if (typeof elem.detachEvent !== ''undefined'') {\n        elem.detachEvent(''on'' + type);\n    }\n}\n```\n\n## 取消冒泡（兼容）\n```\nfunction stopBubble(event) {\n    if (event.stopPropagation) {\n        event.stopPropagation();\n    } else {\n        event.cancelBubble = true;\n    }\n}\n```\n\n## 阻止默认事件函数\n```\nfunction cancelHandler(event) {\n    if (event.preventDefault) {\n        event.preventDefault();\n    } else {\n        event.returnValue = false;\n    }\n}\n```\n## 拖拽事件\n```\nfunction drag(elem) {\n    var disX,\n        disY;\n    addEvent(elem, ''mousedown'', function (e) {\n        var event = e || window.event;\n        disX = event.clientX - parseInt(getStyle(elem, ''left''));\n        disY = event.clientY - parseInt(getStyle(elem, ''top''));\n        addEvent(document, ''mousemove'', mouseMove);\n        addEvent(document, ''mouseup'', mouseUp);\n        stopBubble(event);\n        cancelHandler(event);\n    });\n    function mouseMove(e) {\n        var event = e || window.event;\n        elem.style.left = event.clientX - disX + "px";\n        elem.style.top = event.clientY - disY + "px";\n    }\n    function mouseUp(e) {\n        var event = e || window.event;\n        removeEvent(document, ''mousemove'', mouseMove);\n        removeEvent(document, ''mouseup'', mouseUp);\n    }\n}\n```\n## 异步加载（兼容）\n```\nfunction loadScript(url, callback) {\n    var script = document.createElement(''script'');\n    script.type = "text/javascript";\n    if (script.readyState) {\n        script.onreadstatechange = function () {//IE\n            if (script.readyState == "complete" || script.readyStatereadyState == "loaded") {\n                callback();\n            }\n        }\n    } else {\n        script.onload = function () {\n            callback();\n        }\n    }\n    script.src = url;\n    document.head.appendChild(script);\n}\nloadScript(''/*路径*/'', function () {\n    test();\n})\n```\n\n## 获取指定标签对象\n```\n/**\n * 获取指定标签对象\n * @param id 标签的id属性值\n * @returns {Element}根据id属性值返回指定标签对象\n */\nfunction my$(id) {\n    return document.getElementById(id);\n}\n```\n\n## 设置任意的标签中间的任意文本内容\n```\nfunction setInnerText(element, text) {\n    //判断浏览器是否支持这个属性\n    if (typeof element.textContent == "undefined") {//不支持\n        element.innerText = text;\n    } else {//支持这个属性\n        element.textContent = text;\n    }\n}\nmy$("btn").onclick = function () {\n    console.log(getInnerText(my$("dv")));\n};\n```\n\n## 获取任意标签中间的文本内容\n```\nfunction getInnerText(element) {\n    if (typeof element.textContent == "undefined") {\n        return element.innerText;\n    } else {\n        return element.textContent;\n    }\n}\nmy$("btn").onclick = function () {\n    setInnerText(my$("dv"), "哈哈,我又变帅了");\n};\n```\n\n## 获取任意一个父级元素的第一个子级元素\n```\nfunction getFirstElementChild(element) {\n    if (element.firstElementChild) {//true--->支持\n        return element.firstElementChild;\n    } else {\n        var node = element.firstChild;//第一个节点\n        while (node && node.nodeType != 1) {\n            node = node.nextSibling;\n        }\n        return node;\n    }\n}\nconsole.log(getFirstElementChild(my$("uu")).innerText);\n```\n\n## 获取任意一个父级元素的最后一个子级元素\n```\nfunction getLastElementChild(element) {\n    if (element.lastElementChild) {//true--->支持\n        return element.lastElementChild;\n    } else {\n        var node = element.lastChild;//第一个节点\n        while (node && node.nodeType != 1) {\n            node = node.previousSibling;\n        }\n        return node;\n    }\n}\nconsole.log(getLastElementChild(my$("uu")).innerText);\n```\n\n## 获取某个元素的前一个兄弟元素\n```\n/**\n * 获取某个元素的前一个兄弟元素\n * @param element 某个元素\n * @returns {*} 前一个兄弟元素\n */\nfunction getPreviousElement(element) {\n    if (element.previousElementSibling) {\n        return element.previousElementSibling\n    } else {\n        var node = element.previousSibling;\n        while (node && node.nodeType != 1) {\n            node = node.previousSibling;\n        }\n        return node;\n    }\n}\n```\n\n## 获取某个元素的后一个兄弟元素\n```\n/**\n * 获取某个元素的后一个兄弟元素\n * @param element 某个元素\n * @returns {*} 后一个兄弟元素\n */\nfunction getNextElement(element) {\n    if (element.nextElementSibling) {\n        return element.nextElementSibling\n    } else {\n        var node = element.nextSibling;\n        while (node && node.nodeType != 1) {\n            node = node.nextSibling;\n        }\n        return node;\n    }\n}\n```\n## 获取某个元素的所有兄弟元素\n```\n/**\n * 获取某个元素的所有兄弟元素\n * @param element 某个元素\n * @returns {Array} 兄弟元素\n */\nfunction getSiblings(element) {\n    if (!element) return;\n    var elements = [];\n    var ele = element.previousSibling;\n    while (ele) {\n        if (ele.nodeType === 1) {\n            elements.push(ele);\n        }\n        ele = ele.previousSibling;\n    }\n    ele = element.nextSibling;\n    while (ele) {\n        if (ele.nodeType === 1) {\n            elements.push(ele);\n\n        }\n        ele = ele.nextSibling;\n    }\n    return elements;\n}\n```\n\n\n## 为任意元素.绑定任意的事件, 任意的元素,事件的类型,事件处理函数\n```\nfunction addEventListener(element, type, fn) {\n    //判断浏览器是否支持这个方法\n    if (element.addEventListener) {\n        element.addEventListener(type, fn, false);\n    } else if (element.attachEvent) {\n        element.attachEvent("on" + type, fn);\n    } else {\n        element["on" + type] = fn;\n    }\n}\n```\n## 为任意的一个元素,解绑对应的事件\n```\nfunction removeEventListener(element, type, fnName) {\n    if (element.removeEventListener) {\n        element.removeEventListener(type, fnName, false);\n    } else if (element.detachEvent) {\n        element.detachEvent("on" + type, fnName);\n    } else {\n        element["on" + type] = null;\n    }\n}\n```\n\n## 格式化日期\n```\n/**\n * 格式化日期\n * @param dt 日期对象\n * @returns {string} 返回值是格式化的字符串日期\n */\nfunction getDates(dt) {\n    var str = "";//存储时间的字符串\n    //获取年\n    var year = dt.getFullYear();\n    //获取月\n    var month = dt.getMonth() + 1;\n    //获取日\n    var day = dt.getDate();\n    //获取小时\n    var hour = dt.getHours();\n    //获取分钟\n    var min = dt.getMinutes();\n    //获取秒\n    var sec = dt.getSeconds();\n    month = month < 10 ? "0" + month : month;\n    day = day < 10 ? "0" + day : day;\n    hour = hour < 10 ? "0" + hour : hour;\n    min = min < 10 ? "0" + min : min;\n    sec = sec < 10 ? "0" + sec : sec;\n    str = year + "年" + month + "月" + day + "日 " + hour + ":" + min + ":" + sec;\n    return str;\n}\n```\n\n## 返回当前浏览器是什么类型的浏览器\n```\nfunction userBrowser() {\n    var browserName = navigator.userAgent.toLowerCase();\n    if (/msie/i.test(browserName) && !/opera/.test(browserName)) {\n        console.log("IE");\n    } else if (/firefox/i.test(browserName)) {\n        console.log("Firefox");\n    } else if (/chrome/i.test(browserName) && /webkit/i.test(browserName) && /mozilla/i.test(browserName)) {\n        console.log("Chrome");\n    } else if (/opera/i.test(browserName)) {\n        console.log("Opera");\n    } else if (/webkit/i.test(browserName) && !(/chrome/i.test(browserName) && /webkit/i.test(browserName) && /mozilla/i.test(browserName))) {\n        console.log("Safari");\n    } else {\n        console.log("不知道什么鬼!");\n    }\n}\n```\n## 动画函数---任意一个元素移动到指定的目标位置\n```\nfunction animate(element, target) {\n    //先清理定时器\n    clearInterval(element.timeId);\n    //一会要清理定时器(只产生一个定时器)\n    element.timeId = setInterval(function () {\n        //获取div的当前的位置\n        var current = element.offsetLeft;//数字类型,没有px\n        //div每次移动多少像素---步数\n        var step = 10;\n        step = current < target ? step : -step;\n        //每次移动后的距离\n        current += step;\n        //判断当前移动后的位置是否到达目标位置\n        if (Math.abs(target - current) > Math.abs(step)) {\n            element.style.left = current + "px";\n        } else {\n            //清理定时器\n            clearInterval(element.timeId);\n            element.style.left = target + "px";\n        }\n    }, 20);\n}\nmy$("btn2").onclick = function () {\n    animate(my$("dv"), 800);\n};\n\n```\n\n## 变速动画-任意一个元素移动到指定的目标位置\n```\nfunction animateChange(element, target) {\n    //清理定时器\n    clearInterval(element.timeId);\n    element.timeId = setInterval(function () {\n      //获取元素的当前位置\n      var current = element.offsetLeft;\n      //移动的步数\n      var step = (target-current)/10;\n      step = step>0?Math.ceil(step):Math.floor(step);\n      current += step;\n      element.style.left = current + "px";\n      if(current==target) {\n        //清理定时器\n        clearInterval(element.timeId);\n      }\n      //测试代码:\n      console.log("目标位置:"+target+",当前位置:"+current+",每次移动步数:"+step);\n    }, 20);\n  }\n  my$("btn2").onclick = function () {\n    animateChange(my$("dv"), 800);\n};\n```\n\n## foreach的兼容代码\n```\nif (!Array.prototype.forEach) {\n\n    Array.prototype.forEach = function (callback, thisArg) {\n\n        var T, k;\n\n        if (this == null) {\n            throw new TypeError('' this is null or not defined'');\n        }\n\n        // 1. Let O be the result of calling toObject() passing the\n        // |this| value as the argument.\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get() internal\n        // method of O with the argument "length".\n        // 3. Let len be toUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \n        // See: http://es5.github.com/#x9.11\n        if (typeof callback !== "function") {\n            throw new TypeError(callback + '' is not a function'');\n        }\n\n        // 5. If thisArg was supplied, let T be thisArg; else let\n        // T be undefined.\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n\n        // 6. Let k be 0\n        k = 0;\n\n        // 7. Repeat, while k < len\n        while (k < len) {\n\n            var kValue;\n\n            // a. Let Pk be ToString(k).\n            //    This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the HasProperty\n            //    internal method of O with argument Pk.\n            //    This step can be combined with c\n            // c. If kPresent is true, then\n            if (k in O) {\n\n                // i. Let kValue be the result of calling the Get internal\n                // method of O with argument Pk.\n                kValue = O[k];\n\n                // ii. Call the Call internal method of callback with T as\n                // the this value and argument list containing kValue, k, and O.\n                callback.call(T, kValue, k, O);\n            }\n            // d. Increase k by 1.\n            k++;\n        }\n        // 8. return undefined\n    };\n}\n```\n', 'JS封装方法总结\n```\nfunction addEventListener(element, type, fn) {\n    if (element.addEventListener) {\n        element.addEventListener(type, fn, false);\n    } else if (element.attachEvent) {\n        element.attachEvent("on" + type, fn);\n    } else {\n        element["on" + type] = fn;\n    }\n}\n```', 1582992000, 25, 1),
(17, 2, 'JS-2048小游戏', '# JS-实现2048小游戏\n\n## index.html\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <script src="index.js"></script>\n    <link href="index.css" rel="stylesheet" />\n</head>\n\n<body>\n    <div id="my2048"></div>\n</body>\n\n</html>\n```\n\n## index.css\n\n```\nbody, div, span, a {\n    margin: 0;\n    padding: 0;\n}\n\n#my2048 {\n    margin-left: auto;\n    margin-right: auto;\n    margin-top: 300px;\n    position: relative;\n    background: #bbada0;\n}\n\n#my2048 div {\n    position: absolute;\n    display: inline-block;\n    border: 0px;\n}\n\n```\n\n## index.js\n```\nvar my2048;\nvar rows = 4;\nvar cols = 4;\nvar squareWidth = 100;\nvar spacing = 12;\nvar boardSet = [];\nvar squareSet = [];\nvar valueMap = [];\nvar colorMapping = {"0": "#ccc0b3", "2": "#eee4da", "4": "#ede0c8", "8": "#f2b179", "16": "#f59563", "32": "#f67e5f", "64": "#f65e3b", "128": "#edcf72", "256" : "#edcc61", "512": "#9c0", "1024": "#33b5e5", "2048": "#09c", "4096": "#5b67ff"};\nvar directionEnum = {left:{x:-1, y:0, key:"left"}, right:{x:1, y:0, key:"left"}, top:{x:0, y:-1, key:"top"}, down:{x:0, y:1, key:"top"}};\nvar lock = true;\nvar isChange = false;\n\nfunction move(direction) {\n    if (isOver()) {\n        alert("game over ~!");\n        return;\n    }\n    var newSquareSet = analysisActions(direction);\n    //收尾(保证最终一致性)\n    setTimeout(function () {\n        refresh(newSquareSet);\n        if (isChange) {\n            randGenerateSquare();\n        }\n        lock = true;\n        isChange = false;\n    }, 300);\n}\n\nfunction analysisActions(direction) {\n    var newSquareSet = generateNullMap();\n    if (direction == directionEnum.left) {//向左\n        console.log("向左");\n        for (var i = 0 ; i < squareSet.length ; i ++) {\n            var temp = [];\n            for (var j = 0 ; j < squareSet[i].length ; j ++) {\n                if (squareSet[i][j] != null) {\n                    temp.push(squareSet[i][j]);\n                }\n            }\n            temp = getNewLocation(temp);\n            for (var k = 0 ; k < newSquareSet[i].length ; k ++) {\n                if (temp[k]) {\n                    newSquareSet[i][k] = temp[k];\n                }\n            }\n        }\n    } else if (direction == directionEnum.right) {//向右\n        console.log("向右");\n        for (var i = 0 ; i < squareSet.length ; i ++) {\n            var temp = [];\n            for (var j = squareSet[i].length - 1 ; j >= 0 ; j --) {\n                if (squareSet[i][j] != null) {\n                    temp.push(squareSet[i][j]);\n                }\n            }\n            temp = getNewLocation(temp);\n            for (var k = newSquareSet[i].length - 1 ; k >= 0 ; k --) {\n                if (temp[newSquareSet[i].length - 1 - k]) {\n                    newSquareSet[i][k] = temp[newSquareSet[i].length - 1 - k];\n                }\n            }\n        }\n    } else if (direction == directionEnum.top) {//向前\n        console.log("向前");\n        for (var j = 0 ; j < squareSet[0].length ; j ++) {\n            var temp = [];\n            for (var i = 0 ; i < squareSet.length ; i ++) {\n                if (squareSet[i][j] != null) {\n                    temp.push(squareSet[i][j]);\n                }\n            }\n            temp = getNewLocation(temp);\n            for (var k = 0 ; k < newSquareSet.length ; k ++) {\n                if (temp[k]) {\n                    newSquareSet[k][j] = temp[k];\n                }\n            }\n        }\n    } else {//向后\n        console.log("向后");\n        for (var j = 0 ; j < squareSet[0].length ; j ++) {\n            var temp = [];\n            for (var i = squareSet.length - 1 ; i >= 0 ; i --) {\n                if (squareSet[i][j] != null) {\n                    temp.push(squareSet[i][j]);\n                }\n            }\n            temp = getNewLocation(temp);\n            for (var k = newSquareSet.length - 1 ; k >= 0 ; k --) {\n                if (temp[newSquareSet.length - 1 - k]) {\n                    newSquareSet[k][j] = temp[newSquareSet.length - 1 - k];\n                }\n            }\n        }\n    }\n    //动画\n    for (var i = 0 ; i < newSquareSet.length ; i ++) {\n        for (var j = 0 ; j < newSquareSet[i].length ; j ++) {\n            if (newSquareSet[i][j] == null) {\n                continue;\n            }\n            newSquareSet[i][j].style.transition = direction.key + " 0.3s";\n            newSquareSet[i][j].style.left = (j + 1) * spacing + j * squareWidth + "px";\n            newSquareSet[i][j].style.top = (i + 1) * spacing + i * squareWidth + "px";\n            if(newSquareSet[i][j].nextSquare) {\n                newSquareSet[i][j].nextSquare.style.transition = direction.key + " 0.3s";\n                newSquareSet[i][j].nextSquare.style.left = (j + 1) * spacing + j * squareWidth + "px";\n                newSquareSet[i][j].nextSquare.style.top = (i + 1) * spacing + i * squareWidth + "px";\n            }\n        }\n    }\n    return newSquareSet;\n}\n\nfunction getNewLocation(arr) {\n    if (arr.length == 0) {\n        return [];\n    }\n    var temp = [];\n    temp.push(arr[0]);\n    for (var i = 1 ; i < arr.length ; i ++) {\n        if (arr[i].num == temp[temp.length - 1].num && (!temp[temp.length - 1].nextSquare || temp[temp.length - 1].nextSquare == null)) {\n            temp[temp.length - 1].nextSquare = arr[i];\n        } else {\n            temp.push(arr[i]);\n        }\n    }\n    return temp;\n}\n\nfunction generateNullMap () {\n    var newValueMap = [];\n    for (var i = 0 ; i < rows ; i ++) {\n        newValueMap[i] = [];\n        for (var j = 0 ; j < cols ; j ++) {\n            newValueMap[i][j] = null;\n        }\n    }\n    return newValueMap;\n}\n\nfunction isOver() {\n    for (var i = 0 ; i < squareSet.length ; i ++) {\n        for (var j = 0 ; j < squareSet[i].length ; j ++) {\n            if (squareSet[i][j] == null) {\n                return false;\n            }\n            if (squareSet[i][j + 1] && squareSet[i][j].num == squareSet[i][j + 1].num || squareSet[i + 1] && squareSet[i + 1][j] && squareSet[i][j].num == squareSet[i + 1][j].num){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction refresh(newSquareSet) {//纠正位图，保证最终一致性\n    squareSet = generateNullMap();\n    var newValueMap = generateNullMap();\n    for (var i = 0 ; i < rows ; i ++) {\n        for (var j = 0 ; j < cols ; j ++) {\n            //新的存在则添加\n            if (newSquareSet[i][j]) {\n                if (newSquareSet[i][j].nextSquare) {\n                    var temp = createSquare(newSquareSet[i][j].num * 2, newSquareSet[i][j].offsetLeft, newSquareSet[i][j].offsetTop, i, j);\n                    squareSet[i][j] = temp;\n                    my2048.append(temp);\n                    my2048.removeChild(newSquareSet[i][j].nextSquare);\n                    my2048.removeChild(newSquareSet[i][j]);\n                } else {\n                    var temp = createSquare(newSquareSet[i][j].num, newSquareSet[i][j].offsetLeft, newSquareSet[i][j].offsetTop, i, j);\n                    squareSet[i][j] = temp;\n                    my2048.append(temp);\n                    my2048.removeChild(newSquareSet[i][j]);\n                }\n                if (valueMap[i][j] != squareSet[i][j].num) {\n                    isChange = true;\n                }\n                newValueMap[i][j] = squareSet[i][j].num;\n            } else {\n                newValueMap[i][j] = 0;\n            }\n        }\n    }\n    valueMap = newValueMap;\n}\n\nfunction randSquareNum() {\n    return Math.random() >= 0.5 ? 4 : 2;\n}\n\nfunction randGenerateSquare() {\n    for (;;) {\n        var randRow = Math.floor(Math.random() * rows);\n        var randCol = Math.floor(Math.random() * cols);\n        if (valueMap[randRow][randCol] == 0) {\n            var temp = createSquare(randSquareNum(), randCol * squareWidth + (randCol + 1) * spacing, randRow * squareWidth + (randRow + 1) * spacing, randRow, randCol);\n            valueMap[temp.row][temp.col] = temp.num;\n            squareSet[temp.row][temp.col] = temp;\n            my2048.appendChild(temp);\n            return true;\n        }\n    }\n}\n\nfunction createSquare(value, left, top, row, col) {\n    var temp = document.createElement("div");\n    temp.style.width = squareWidth + "px";\n    temp.style.height = squareWidth + "px";\n    temp.style.left = left + "px";\n    temp.style.top = top + "px";\n    temp.style.background = colorMapping[value];\n    temp.style.lineHeight = squareWidth + "px";\n    temp.style.textAlign = "center";\n    temp.style.fontSize = 0.4 * squareWidth + "px";\n    temp.num = value;\n    temp.row = row;\n    temp.col = col;\n    if (value > 0) {\n        temp.innerHTML = "" + value;\n    }\n    return temp;\n}\n\nfunction initBoard() {\n    my2048 = document.getElementById("my2048");\n    my2048.style.width = cols * squareWidth + (cols + 1) * spacing + "px";\n    my2048.style.height = rows * squareWidth + (rows + 1) * spacing + "px";\n}\n\nfunction init() {\n    //初始化棋盘\n    initBoard();\n    for (var i = 0 ; i < rows ; i ++){\n        boardSet[i] = [];\n        valueMap[i] = [];\n        squareSet[i] = [];\n        for (var j = 0 ; j < cols ; j ++){\n            valueMap[i][j] = 0;\n            squareSet[i][j] = null;\n            boardSet[i][j] = createSquare(0, j * squareWidth + (j + 1) * spacing, i * squareWidth + (i + 1) * spacing, i, j);\n            my2048.appendChild(boardSet[i][j]);\n        }\n    }\n    //初始化方块\n    randGenerateSquare();\n    randGenerateSquare();\n    //添加事件\n    document.addEventListener("keydown", function(e) {\n        if (!lock) return;\n        lock = false;\n        switch (e.key) {\n            case "ArrowUp": move(directionEnum.top);break;\n            case "ArrowDown": move(directionEnum.down);break;\n            case "ArrowLeft": move(directionEnum.left);break;\n            case "ArrowRight": move(directionEnum.right);break;\n            default : {\n                lock = true;\n            }\n        }\n    });\n}\n\nwindow.onload = function () {\n    init();\n}\n```', '简单的2048小游戏\n```\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <script src="index.js"></script>\n    <link href="index.css" rel="stylesheet" />\n</head>\n\n<body>\n    <div id="my2048"></div>\n</body>\n```', 1582992000, 20, 0),
(18, 2, 'CSS-太空船动画', '# CSS-实现太空船动画\n\n## index.html\n```\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n   <link rel="stylesheet" href="index.css">\n</head>\n<body>\n    <div class="spaceship">\n        <div class="spaceshipBody">\n           <div class="spaceshipTop"></div>\n           <div class="spaceshipWindows">\n              <span></span>\n              <span></span>\n           </div>\n        </div>\n        <div class="spaceshipBottom">\n           <span></span>\n           <span></span>\n           <span></span>\n        </div>\n        <div class="fire">\n           <span></span>\n           <span></span>\n           <span></span>\n           <div class="glow"></div>\n        </div>\n     </div>\n     <div class="shadow"></div>\n     <div class="buttons">\n        <button class="btnStart"><span>start</span></button>\n        <button class="btnLaunch"><span>launch</span></button>\n        <button disabled="disabled" class="btnLand disable"><span>land</span></button>\n     </div>\n       \n</body>\n<script src="index.js"></script>\n</html>\n```\n## index.css\n```\nbody {\n    margin: 0;\n    padding: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n    width: 100%;\n    background-color: #0f1b31;\n  }\n  \n  .spaceship {\n    width: 300px;\n    height: 300px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: absolute;\n    transition: all 2s ease;\n    bottom: 130px;\n    animation: float 2s ease infinite alternate;\n  }\n  @keyframes float {\n    0% {\n      transform: translateY(10px);\n    }\n    100% {\n      transform: translateY(0px);\n    }\n  }\n  .spaceship.launch {\n    bottom: 120%;\n    animation: launch 3s ease;\n  }\n  @keyframes launch {\n    0% {\n      bottom: 130px;\n      transform: translatex(2px);\n    }\n    10% {\n      transform: translatex(-2px);\n    }\n    20% {\n      transform: translatex(2px);\n    }\n    30% {\n      transform: translatex(-2px);\n    }\n    60% {\n      transform: translatex(0px);\n      bottom: 150px;\n    }\n    100% {\n      bottom: 120%;\n    }\n  }\n  .spaceship.land {\n    bottom: 130px;\n    animation: land 3s ease;\n  }\n  @keyframes land {\n    0% {\n      bottom: 120%;\n    }\n    50% {\n      bottom: 180px;\n    }\n    100% {\n      bottom: 130px;\n    }\n  }\n  .spaceship .spaceshipBody {\n    width: 35%;\n    height: 80%;\n    background-color: white;\n    border-bottom-left-radius: 100%;\n    border-bottom-right-radius: 100%;\n    border-top-left-radius: 100%;\n    border-top-right-radius: 100%;\n    display: flex;\n    justify-content: center;\n    position: relative;\n    z-index: 1;\n    box-shadow: inset 0px -173px 0px -80px white, inset 0px -213px 0px -60px #e4e4e4;\n  }\n  .spaceship .spaceshipBody:before {\n    content: "";\n    position: absolute;\n    width: calc(100% - 36px);\n    height: 42%;\n    background-color: inherit;\n    bottom: -30px;\n    transform: perspective(10em) rotateX(-50deg);\n    border-bottom-left-radius: 50px;\n    border-bottom-right-radius: 50px;\n    box-shadow: inset 0px -33px 0px 0px rgba(0, 0, 0, 0.1);\n  }\n  .spaceship .spaceshipBody:after {\n    content: "";\n    position: absolute;\n    width: 45%;\n    height: 40px;\n    background-color: #f95959;\n    bottom: -20px;\n    transform: perspective(10em) rotateX(-50deg);\n    border-bottom-left-radius: 50px;\n    border-bottom-right-radius: 50px;\n    z-index: -1;\n  }\n  .spaceship .spaceshipBody .spaceshipTop {\n    width: 100%;\n    height: 240px;\n    border-radius: 100%;\n    overflow: hidden;\n    position: relative;\n    box-shadow: inset -12px 17px 0px -7px rgba(0, 0, 0, 0.15);\n  }\n  .spaceship .spaceshipBody .spaceshipTop:before {\n    content: "";\n    background-color: #4ba3b7;\n    position: absolute;\n    width: 100%;\n    height: 100px;\n    left: calc(50% - 54%);\n    border-radius: 100%;\n    top: -55px;\n    border: 2px solid white;\n    box-shadow: inset -18px 56px 0px 3px rgba(0, 0, 0, 0.1), 0px 0px 0px 6px #f95959;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 300px;\n    height: 300px;\n    position: absolute;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span {\n    background-color: #ace7ef;\n    box-shadow: inset -4px 4px 0px 0px rgba(0, 0, 0, 0.3), inset 0px 0px 0px 2px white;\n    border: 4px solid #f95959;\n    z-index: 2;\n    position: absolute;\n    border-radius: 100%;\n    overflow: hidden;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span:before {\n    position: absolute;\n    content: "";\n    background-color: white;\n    width: 200%;\n    height: 100%;\n    transform: rotate(45deg);\n    opacity: 0.4;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span:nth-child(1) {\n    width: 30px;\n    height: 30px;\n    top: 23%;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span:nth-child(1):before {\n    top: 10px;\n    right: 0px;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span:nth-child(2) {\n    width: 45px;\n    height: 45px;\n    top: 40%;\n  }\n  .spaceship .spaceshipBody .spaceshipWindows span:nth-child(2):before {\n    top: 12px;\n    right: 0px;\n  }\n  .spaceship .spaceshipBottom {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 300px;\n    height: 300px;\n    position: absolute;\n  }\n  .spaceship .spaceshipBottom span {\n    background-color: #4ba3b7;\n    border-radius: 10px;\n    position: absolute;\n    overflow: hidden;\n  }\n  .spaceship .spaceshipBottom span:before {\n    content: "";\n    position: absolute;\n    background-color: white;\n    width: 2px;\n    height: 120%;\n    border-radius: 20px;\n  }\n  .spaceship .spaceshipBottom span:nth-child(1) {\n    width: 15px;\n    height: 80px;\n    z-index: 2;\n    bottom: 2%;\n    box-shadow: inset -5px -3px 0px 0px rgba(0, 0, 0, 0.18);\n  }\n  .spaceship .spaceshipBottom span:nth-child(1):before {\n    display: none;\n  }\n  .spaceship .spaceshipBottom span:nth-child(2) {\n    width: 50px;\n    height: 130px;\n    left: 32%;\n    bottom: 6%;\n    transform: perspective(10em) rotateX(60deg) translateZ(-1px);\n    box-shadow: inset -5px -3px 0px 0px rgba(0, 0, 0, 0.2);\n  }\n  .spaceship .spaceshipBottom span:nth-child(2):before {\n    left: 0px;\n    border-right: 2px solid #f95959;\n  }\n  .spaceship .spaceshipBottom span:nth-child(3) {\n    width: 50px;\n    height: 130px;\n    right: 32%;\n    bottom: 6%;\n    transform: perspective(10em) rotateX(60deg) translateZ(-1px);\n    box-shadow: inset -5px -3px 0px 0px rgba(0, 0, 0, 0.2);\n  }\n  .spaceship .spaceshipBottom span:nth-child(3):before {\n    right: 0px;\n    border-left: 2px solid #f95959;\n  }\n  .spaceship .fire {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 300px;\n    height: 100px;\n    position: absolute;\n    bottom: -50px;\n  }\n  .spaceship .fire.burn span {\n    border-radius: 50px;\n    top: 0;\n    position: absolute;\n    background-color: #ffd460;\n    height: inherit;\n    animation: fire 0.8s ease infinite alternate;\n  }\n  .spaceship .fire.burn span:nth-child(1) {\n    width: 6px;\n    height: 40px;\n    left: 44%;\n    transform: translateY(27px);\n    box-shadow: inset 0px -7px 10px #ea5455, inset 0px -19px 10px #ffc175, 0px -7px 10px #ea5455;\n    animation-delay: 0.2s;\n  }\n  .spaceship .fire.burn span:nth-child(1):after {\n    position: absolute;\n    content: "";\n    width: 4px;\n    height: 60%;\n    border-radius: 50px;\n    background-color: #ffd460;\n    bottom: 0;\n    transform: translate(8px, 15px);\n    box-shadow: inset 0px -5px 10px #ea5455, inset 0px -19px 10px #ffc175, 0px -7px 10px #ea5455;\n  }\n  .spaceship .fire.burn span:nth-child(2) {\n    width: 10px;\n    height: 60px;\n    left: calc(50% - 8px);\n    transform: translateY(35px);\n    box-shadow: inset 0px -10px 10px #ea5455, inset 0px -30px 10px #ffc175, 0px -7px 10px #ea5455;\n  }\n  .spaceship .fire.burn span:nth-child(2):after {\n    position: absolute;\n    content: "";\n    width: 10px;\n    height: 100%;\n    border-radius: 10px;\n    background-color: #ffd460;\n    top: 0;\n    transform: translate(-6px, -25px);\n    box-shadow: inset 0px -5px 10px #ea5455, inset 0px -15px 10px #ffc175, 0px -7px 10px #ea5455;\n  }\n  .spaceship .fire.burn span:nth-child(3) {\n    width: 10px;\n    height: 40px;\n    right: 45%;\n    transform: translateY(27px);\n    box-shadow: inset 0px -5px 10px #ea5455, inset 0px -30px 10px #ffc175, 0px -7px 10px #ea5455;\n    animation-delay: 0.4s;\n  }\n  .spaceship .fire.burn span:nth-child(3):after {\n    position: absolute;\n    content: "";\n    width: 6px;\n    height: 180%;\n    border-radius: 10px;\n    background-color: #ffd460;\n    top: 0;\n    transform: translate(-6px, -15px);\n    box-shadow: inset 0px -5px 10px #ea5455, inset 0px -20px 10px #ffc175, 0px -7px 10px #ea5455;\n  }\n  @keyframes fire {\n    0% {\n      height: 10px;\n      bottom: 0;\n    }\n      50% {\n        top: 0;\n      }\n      100% {\n        height: 20px;\n        bottom: 0;\n      }\n    }\n  .spaceship .fire.burn .glow {\n    position: absolute;\n    width: 0px;\n    height: 0px;\n    border-radius: 100%;\n    box-shadow: 0px 0px 50px 20px #ea5455;\n    opacity: 1;\n    animation: glow 0.8s ease infinite alternate;\n  }\n  @keyframes glow {\n    0% {\n      box-shadow: 0px 0px 50px 20px #ea5455;\n    }\n    100% {\n      box-shadow: 0px 0px 50px 25px #ea5455;\n    }\n  }\n  .shadow {\n    width: 150px;\n    height: 30px;\n    background-color: black;\n    position: absolute;\n    border-radius: 100%;\n    opacity: 0.2;\n    bottom: 80px;\n    z-index: -1;\n    animation: shadow 2s ease infinite alternate;\n    transition: all 0.5s ease;\n  }\n  @keyframes shadow {\n    0% {\n      width: 150px;\n    }\n    100% {\n      width: 120px;\n    }\n  }\n  .buttons {\n    position: absolute;\n    display: flex;\n    flex-direction: column;\n    justify-content: space-around;\n    top: 20px;\n    left: 20px;\n  }\n  .buttons button {\n    width: 100px;\n    height: 40px;\n    background-color: #4ba3b7;\n    border: 0;\n    margin: 8px;\n    color: white;\n    position: relative;\n    overflow: hidden;\n    font-size: 12px;\n    letter-spacing: 1px;\n    font-weight: 500;\n    text-transform: uppercase;\n    transition: all 0.3s ease;\n    cursor: pointer;\n    border-radius: 3px;\n  }\n  .buttons button.active {\n    background-color: #f95959;\n  }\n  .buttons button.active:hover {\n    letter-spacing: 1px;\n    color: white;\n    background-color: #bf4c4c;\n  }\n  .buttons button.active:hover:before, .buttons button.active:hover:after {\n    width: 0;\n  }\n  .buttons button.active:hover span:before, .buttons button.active:hover span:after {\n    height: 0;\n  }\n  .buttons button.disable {\n    background-color: grey;\n    opacity: 0.3;\n    cursor: auto;\n  }\n  .buttons button.disable:hover {\n    letter-spacing: 1px;\n    color: white;\n  }\n  .buttons button.disable:hover:before, .buttons button.disable:hover:after {\n    width: 0;\n  }\n  .buttons button.disable:hover span:before, .buttons button.disable:hover span:after {\n    height: 0;\n  }\n  .buttons button:before {\n    content: "";\n    position: absolute;\n    width: 0;\n    height: 2px;\n    background-color: #ace7ef;\n    transition: all 0.4s ease;\n    left: 0;\n    top: 0;\n  }\n  .buttons button:after {\n    content: "";\n    position: absolute;\n    width: 0;\n    height: 2px;\n    background-color: #ace7ef;\n    transition: all 0.4s 0.2s ease;\n    right: 0;\n    bottom: 0;\n  }\n  .buttons button span {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  .buttons button span:before {\n    content: "";\n    position: absolute;\n    width: 2px;\n    height: 0;\n    background-color: #ace7ef;\n    transition: all 0.4s 0.3s ease;\n    left: 0;\n    top: 0;\n  }\n  .buttons button span:after {\n    content: "";\n    position: absolute;\n    width: 2px;\n    height: 0;\n    background-color: #ace7ef;\n    transition: all 0.4s 0.4s ease;\n    right: 0;\n    bottom: 0;\n  }\n  .buttons button:hover {\n    color: #ace7ef;\n    letter-spacing: 2px;\n  }\n  .buttons button:hover:before, .buttons button:hover:after {\n    width: 100%;\n  }\n  .buttons button:hover span:before, .buttons button:hover span:after {\n    height: 100%;\n  }\n  .buttons button:active {\n    outline: none;\n    border: none;\n  }\n  .buttons button:focus {\n    outline: 0;\n  }\n  \n```\n## index.js\n\n```\nvar spaceship = document.querySelector(".spaceship"),\n    fire = document.querySelector(".fire"),\n    btnLaunch = document.querySelector(".btnLaunch"),\n    btnLand = document.querySelector(".btnLand"),\n    btnStart = document.querySelector(".btnStart"),\n    txtLaunch = document.querySelector(".btnLaunch span"),\n    txtLand = document.querySelector(".btnLand span"),\n    txtStart = document.querySelector(".btnStart span"),\n    shadow = document.querySelector(".shadow");\n\nbtnLaunch.addEventListener("click", launch);\nbtnLand.addEventListener("click", land);\nbtnStart.addEventListener("click", start);\n\nfunction launch() {\n   btnStart.classList.add("disable");\n   fire.classList.add("burn");\n   spaceship.classList.remove("land");\n   spaceship.classList.add("launch");\n   spaceship.removeEventListener("animationend", burn);\n   shadow.style.opacity = "0";\n\n   /*buttons*/\n   btnLaunch.classList.add("active");\n   btnStart.disabled = true;\n   btnStart.classList.remove("active");\n   btnLand.classList.remove("active");\n   btnLand.classList.remove("disable");\n   btnLand.disabled = false;\n\n   /*text buttons*/\n   txtLaunch.innerText = "launched!";\n   txtStart.innerText = "start";\n   txtLand.innerText = "land";\n}\n\nfunction land() {\n   spaceship.classList.remove("launch");\n   spaceship.classList.add("land");\n   spaceship.addEventListener("animationend", burn);\n  \n   /*buttons*/\n   btnLaunch.classList.remove("active");\n   btnLand.classList.add("active");\n   btnStart.classList.remove("disable");\n   btnStart.disabled = false;\n   /*text buttons*/\n   txtLand.innerText = "landed!";\n   txtLaunch.innerText = "launch";\n}\n\nfunction burn() {\n   fire.classList.remove("burn");\n   spaceship.classList.remove("land");\n   shadow.style.opacity = "0.2";\n   /*buttons*/\n   btnLand.classList.remove("active");\n   btnLand.classList.add("disable");\n   btnLand.disabled = true;\n   /*text buttons*/\n   txtLand.innerText = "land";\n}\n\nfunction start() {\n   if (btnStart.classList.contains("active")) {\n      fire.classList.remove("burn");\n      btnStart.classList.remove("active");\n      txtStart.innerText = "start";\n   } else {\n      fire.classList.add("burn");\n      btnStart.classList.add("active");\n      txtStart.innerText = "stop";\n      btnLand.classList.remove("active");\n   }\n}\n\nfunction stop() {\n   fire.classList.remove("burn");\n}\n```', 'CSS-实现太空船动画\n```\n  @keyframes launch {\n    0% {\n      bottom: 130px;\n      transform: translatex(2px);\n    }\n    10% {\n      transform: translatex(-2px);\n    }\n    20% {\n      transform: translatex(2px);\n    }\n    30% {\n      transform: translatex(-2px);\n    }\n    60% {\n      transform: translatex(0px);\n      bottom: 150px;\n    }\n    100% {\n      bottom: 120%;\n    }\n  }\n```', 1582992000, 15, 0);
INSERT INTO `article` (`Id`, `type_id`, `title`, `article_content`, `introduce`, `addTime`, `view_count`, `isTop`) VALUES
(19, 2, 'JS-抖音很火的文字时钟', '# JS-文字时钟\n\n## index.html\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <link rel="stylesheet" href="index.css">\n</head>\n\n<body>\n    <div id="clock"></div>\n    <script src="index.js"></script>\n</body>\n\n</html>\n```\n\n## index.css\n```\n*{\n    margin:0;\n    padding:0;\n}\nhtml,body{\n    width:100%;\n    height:100%;\n    background-color: #000;\n    overflow: hidden;\n}\n#clock {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    background: black;\n}\n.label{\n    display:inline-block;\n    color:#4d4d4d;\n    text-align: center;\n    padding:0 5px;\n    font-size:19px;\n    transition:left 1s,top 1s;\n    transform-origin: 0% 0%;\n}\n\n\n```\n\n## index.js\n```\nvar monthText = ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"];\nvar dayText = ["一号", "二号", "三号", "四号", "五号", "六号", "七号", "八号", "九号", "十号", "十一号", "十二号", "十三号", "十四号", "十五号", "十六号", "十七号", "十八号", "十九号", "二十号", "二十一号", "二十二号", "二十三号", "二十四号", "二十五号", "二十六号", "二十七号", "二十八号", "二十九号", "三十号", "三十一号"];\nvar weekText = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"];\nvar hourText = ["零点", "一点", "两点", "三点", "四点", "五点", "六点", "七点", "八点", "九点", "十点", "十一点", "十二点", "十三点", "十四点", "十五点", "十六点", "十七点", "十八点", "十九点", "二十点", "二十一点", "二十二点", "二十三点"];\nvar minuteText = ["一分", "二分", "三分", "四分", "五分", "六分", "七分", "八分", "九分", "十分",\n    "十一分", "十二分", "十三分", "十四分", "十五分", "十六分", "十七分", "十八分", "十九分", "二十分",\n    "二十一分", "二十二分", "二十三分", "二十四分", "二十五分", "二十六分", "二十七分", "二十八分", "二十九分", "三十分",\n    "三十一分", "三十二分", "三十三分", "三十四分", "三十五分", "三十六分", "三十七分", "三十八分", "三十九分", "四十分",\n    "四十一分", "四十二分", "四十三分", "四十四分", "四十五分", "四十六分", "四十七分", "四十八分", "四十九分", "五十分",\n    "五十一分", "五十二分", "五十三分", "五十四分", "五十五分", "五十六分", "五十七分", "五十八分", "五十九分", "六十分"];\nvar secondsText = ["一秒", "二秒", "三秒", "四秒", "五秒", "六秒", "七秒", "八秒", "九秒", "十秒",\n    "十一秒", "十二秒", "十三秒", "十四秒", "十五秒", "十六秒", "十七秒", "十八秒", "十九秒", "二十秒",\n    "二十一秒", "二十二秒", "二十三秒", "二十四秒", "二十五秒", "二十六秒", "二十七秒", "二十八秒", "二十九秒", "三十秒",\n    "三十一秒", "三十二秒", "三十三秒", "三十四秒", "三十五秒", "三十六秒", "三十七秒", "三十八秒", "三十九秒", "四十秒",\n    "四十一秒", "四十二秒", "四十三秒", "四十四秒", "四十五秒", "四十六秒", "四十七秒", "四十八秒", "四十九秒", "五十秒",\n    "五十一秒", "五十二秒", "五十三秒", "五十四秒", "五十五秒", "五十六秒", "五十七秒", "五十八秒", "五十九秒", "六十秒"];\n\nvar clock;\n// 存放dom元素的数组   \nvar monthList = [];\nvar dayList = [];\nvar weekList = [];\nvar hourList = [];\nvar minuteList = [];\nvar secondsList = [];\n\n// 当前展示是否为圆形\nvar isCircle = false;\n\n//二维数组 存放文字内容及页面显示标签 \nvar textSet = [\n    [monthText, monthList],\n    [dayText, dayList],\n    [weekText, weekList],\n    [hourText, hourList],\n    [minuteText, minuteList],\n    [secondsText, secondsList]\n];\n\nwindow.onload = function () {\n    init();\n    // 每隔100ms获得 当前时间 更新页面时间显示\n    setInterval(function () {\n        runTime();\n    }, 100);\n\n    // 在变成圆形之前先进性修改定位\n    changePosition();\n    // 延迟2000ms变成圆形\n    setTimeout(function () {\n        changeCircle();\n    }, 2000);\n}\n// 初始化函数\nfunction init() {\n    clock = document.getElementById(''clock'');\n    // 生成标签 存放文字展示\n    for (var i = 0; i < textSet.length; i++) {\n        for (var j = 0; j < textSet[i][0].length; j++) {\n            var temp = createLabel(textSet[i][0][j]);\n            clock.appendChild(temp);\n            // 将生成的标签存放在数组list中\n            textSet[i][1].push(temp);\n        }\n    }\n\n}\n\n// 创建标签并将文字填充标签内 接收参数为文字内容  \nfunction createLabel(text) {\n    var div = document.createElement(''div'');\n    div.classList.add(''label'');\n    div.innerText = text;\n    return div;\n}\n\nfunction runTime() {\n    // 利用时间对象获得 当前 时间\n    var now = new Date();\n    // 获得月 日期 小时 分钟 秒钟\n    var month = now.getMonth();\n    var day = now.getDate();\n    var week = now.getDay();\n    var hour = now.getHours();\n    var minute = now.getMinutes();\n    var seconds = now.getSeconds();\n\n    // 初始化时间颜色 同时将走过时间设置为灰色\n    initStyle();\n\n    // 设置当前时间为白色\n    // 将当前时间月份存放在数组中\n    var nowValue = [month, day - 1, week, hour, minute, seconds];\n    for (var i = 0; i < nowValue.length; i++) {\n        var num = nowValue[i];\n        textSet[i][1][num].style.color = ''#fff'';\n    }\n\n    // 变成圆形\n    if (isCircle) {\n        // 确定圆心\n        var widthMid = document.body.clientWidth / 2;\n        var heightMid = document.body.clientHeight / 2;\n        // 将每一个dom元素确定到圆的位置\n        for (var i = 0; i < textSet.length; i++) {\n            for (var j = 0; j < textSet[i][0].length; j++) {\n                // 加算出每一个元素的位置  x y 坐标\n                // 每一个圆的半径与时分秒的位置有关\n                var r = (i + 1) * 35 + 50 * i;\n                // 计算每一个平均的角度  再将每一个单位对齐 然后转化成弧度\n                var deg = 360 / textSet[i][1].length * (j - nowValue[i]) ;\n                // 计算出每一个dom元素的坐标\n                var x = r * Math.sin(deg * Math.PI / 180) + widthMid;\n                var y = heightMid - r*Math.cos(deg * Math.PI / 180);\n                // 设置样式\n                var temp =  textSet[i][1][j];\n                temp.style.transform = ''rotate('' + (-90 + deg ) + ''deg)'';\n                temp.style.left = x + ''px'';\n                temp.style.top = y + ''px'';\n            }\n        }\n    }\n}\n\nfunction initStyle() {\n    // 将所有标签置为灰色 \n    // 利用取出dom元素\n    var label = document.getElementsByClassName(''label'');\n    for (var i = 0; i < label.length; i++) {\n        label[i].style.color = ''#4d4d4d'';\n    }\n    // 利用二维数组存放dom元素的数组\n    // for (var i = 0 ; i < textSet.length ; i ++) {\n    //     for (var j = 0 ; j < textSet[i][0].length ; j ++) {\n    //         textSet[i][1][j].style.color = "#4d4d4d";\n    //     }\n    // }\n}\n\n// 修改position\nfunction changePosition() {\n    for (let i = 0; i < textSet.length; i++) {\n        for (let j = 0; j < textSet[i][1].length; j++) {\n            // 先获得原来的位置  再修改position 设置left top \n            let tempX = textSet[i][1][j].offsetLeft + "px";\n            let tempY = textSet[i][1][j].offsetTop + "px";\n            // console.log(textSet[i][1][j]);\n            // 利用let 防止闭包\n            setTimeout(function () {\n                textSet[i][1][j].style.position = "absolute";\n                textSet[i][1][j].style.left = tempX;\n                textSet[i][1][j].style.top = tempY;\n            }, 50);\n        }\n    }\n}\n\nfunction changeCircle() {\n    isCircle = true;\n    clock.style.transform = "rotate(90deg)";\n}\n```', 'JS-抖音很火的文字时钟\n```\nwindow.onload = function () {\n    init();\n    // 每隔100ms获得 当前时间 更新页面时间显示\n    setInterval(function () {\n        runTime();\n    }, 100);\n\n    // 在变成圆形之前先进性修改定位\n    changePosition();\n    // 延迟2000ms变成圆形\n    setTimeout(function () {\n        changeCircle();\n    }, 2000);\n}\n```', 1582992000, 81, 0),
(20, 1, '常用技术-学习网站', '# 常用学习网站\n\n## 1.W3school\n\n领先的 Web 技术教程 - 全部免费。\n\n在 W3School，你可以找到你所需要的所有的网站建设教程。\n\n从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP .NET。\n\n<a href="https://www.w3school.com.cn/" target="_blank">W3school</a>\n\n---\n\n## 2.菜鸟教程\n\n<p>和W3school一样丰富的学习网站</p>\n\n<a href="https://www.runoob.com/" target="_blank">菜鸟教程</a>\n\n---\n\n## 3.React\n\n<p>React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。\n以声明式编写 UI，可以让你的代码更加可靠，且方便调试。</p>\n\n<a href="https://zh-hans.reactjs.org/" target="_blank">React</a>\n\n---\n\n## 4.VUE\n\n<p>不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</p>\n<p>20kB min+gzip 运行大小超快虚拟 DOM最省心的优化。</p>\n\n<a href="https://cn.vuejs.org/" target="_blank">VUE</a>\n\n---\n\n## 5.Bootstrap\n\n<p>Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。</p>\n\n<a href="https://v3.bootcss.com/" target="_blank">Bootstrap</a>\n\n---\n\n## 6.Layui\n\n<p>经典模块化前端框架</p>\n\n<p>由职业前端倾情打造，面向全层次的前后端开发者，低门槛开箱即用的前端 UI 解决方案。</p>\n\n<a href="https://www.layui.com/" target="_blank">Layui</a>\n\n---\n## 7.Ant Design UI\n\n<p>主要用于研发企业级中后台产品。</p>\n\n<a href="https://ant.design/index-cn" target="_blank">Ant Design</a>\n\n---\n## 8.Element UI\n\n<p>Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库</p>\n\n<a href="https://element.eleme.cn/#/zh-CN" target="_blank">Element UI</a>\n\n---\n## 9.Lin UI\n\n<p>Lin UI 是基于 微信小程序原生语法 实现的组件库。遵循简洁，易用的设计规范。</p>\n\n<a href="http://doc.mini.7yue.pro/" target="_blank">Lin UI</a>\n\n---\n## 10.uni-app\n\n<p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p>\n\n<a href="https://uniapp.dcloud.io/" target="_blank">uni-app</a>\n\n---\n## 11.Taro UI\n\n<p>Taro UI 一套基于 Taro 框架开发的多端 UI 组件库</p>\n\n<a href="https://taro-ui.jd.com/#/" target="_blank"> Taro UI</a>\n\n---\n## 12.Weex\n\n<p>Weex 是一个可以使用现代化的 Web 技术开发高性能原生应用的框架。</p>\n\n<a href="https://weex.apache.org/zh/" target="_blank">Weex</a>\n\n---', '常用技术-学习网站\n```\nhttps://www.w3school.com.cn/\nhttps://www.runoob.com/\nhttps://zh-hans.reactjs.org/\nhttps://cn.vuejs.org/\nhttps://v3.bootcss.com/\n```', 1582992000, 421, 1),
(25, 1, 'git 基础', '# git基础\n>feature_大需求描述    \nhotfix_hotfix描述（bug解决）           \ndaily_20200310 （日常迭代）\ngit add 分支名                     新增文件提交             \ngit commit  -m ''注释''           将本地代码提交到暂存区                \ngit push origin 分支名         将本地代码提交到远程分支             \ngit checkout  -b  分支名      创建新分支并切换到此分支           \ngit pull  origin  分支名         拉取远程分支代码         \ngit log                                  查看代码提交记录       \ngit diff   文件名                     比较本地文件改动    \ngit show  id号                       查看文件改动情况\n \n## 补充\n>1. 修改的代码发现不对，就从暂存区获取代码拉取代码到工作目录   git checkout 文件名\n2. 变基 （让工作目录和暂存区恢复到之前某一时候的代码）   git reset  --hard 版本号\n3. 删除本地分支  切换到主分支 删除其他分支  git branch -d 分支名   git branch -D 分支名 删除的是没有被合并的分支\n4. 删除远程分支   git push origin --delete 分支名\n5. 临时保存开发的代码   git add 分支名 先可以不要commit 提交到暂存区，git  stash存储起来 ,切换到其他分支，再改bug，改完再回来新增刚刚的需求  git stash pop\n6. 解决冲突  拉取最新远程的代码,远程代码版本高于本地代码是不能提交的  git pull origin/分支名 --rebase \n7. git add . 添加所有又不想被Git管理的文件写在 .gitignore   这里面写不想被管理的文件名   （未跟踪）\n8. 解决冲突  例如现在开发的分支代码 低于远程master代码，并且存在代码冲突。本地切换到master分支，git pull  ，再切换到当前分支代码，git merge master，git status ,git commit -a -m ''冲突解决''\n9.git remote add origin 远程仓库地址  添加远程仓库地址\nEP1:\n```\n推送代码可能出现的错    git push origin  远程仓库名\n ! [rejected]        HEAD -> master  (non-fast-forward)\nerror: failed to push some refs to ''git@192.168.96.131:shanghai_policeoffice/cm-app.git''\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: ''git pull ...'') before pushing again.\nhint: See the ''Note about fast-forwards'' in ''git push --help'' for details.\n```  \n```\ngit pull origin 可能被拒绝  (本地仓库未关联远程仓库)\n先关联 再pull 又出现\ngit branch --set-upstream-to=origin/<branch>  本地仓库名\n/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell:3: warning: Insecure world writable dir /usr/local/sbin in PATH, mode 040777\nfatal: refusing to merge unrelated histories\n再同步历史提交记录  \n git pull origin master --allow-unrelated-histories\n出现这个就成功了\n**\n  branch            master     -> FETCH_HEAD\nMerge made by the ''recursive'' strategy.\n README.md | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n create mode 100644 README.md\n**\n最后  git push origin\n```\n', 'git add 分支名                     新增文件提交             \ngit commit  -m ''注释''           将本地代码提交到暂存区                \ngit push origin 分支名         将本地代码提交到远程分支             \ngit checkout  -b  分支名      创建新分支并切换到此分支           \ngit pull  origin  分支名         拉取远程分支代码         \ngit log                                  查看代码提交记录       \ngit diff   文件名                     比较本地文件改动    \ngit show  id号                       查看文件改动情况', 1588521600, 16, 0),
(26, 3, 'eslint的规范配置', 'vscode(版本v1.31.1)中可能出现的两个问题\n============\n1.自动给js加上了分号结束符\n-----\n2.自动将单引号转未双引号\n-----\n\n 解决方案：\n==\n  ```\n"vetur.format.defaultFormatterOptions": {\n   "prettier": {\n     "semi": false,\n     "singleQuote": true\n   }\n  }\n```', 'eslint的规范 在vscode中可能出现的问题', 1584028800, 4, 0),
(27, 3, 'ElementUI中的upload组件的自定义上传行为', 'Elementi中的upload组件的自定义上传的坑\n===\n1.自定义上传：upload组件提供了一个http-request属性，官方给的描述是：覆盖默认的上传行为，可以自定义上传的实现\n\n2.值的回填：upload组件提供了一个file-list属性，描述：上传的文件列表\n\n3.使用自定义上传on-error  on-success两个函数都会失效\n```      \ntemplate部分\n\n<el-upload\n  action="https://up-z2.qbox.me"\n  list-type="picture-card"\n  :http-request="uploadImg"\n  :on-success="uploadImgSuccess"\n  :on-remove="handleRemove">\n  <i class="el-icon-plus"></i>\n</el-upload>\n\n  script部分\nmethods: {\n	uploadImg (f) {\n	  this.axios.get(''./getToken'').then((response) => {//获取token\n	     let param = new FormData(); //创建form对象\n	     param.append(''file'',f.file);//通过append向form对象添加数据\n	     param.append(''token'',response.data.token);//通过append向form对象添加数据\n	     param.append(''key'',response.data.key);//添加form表单中其他数据\n	     let config = {\n	       headers:{''Content-Type'':''multipart/form-data''}\n	     };  //添加请求头\n	     this.axios.post(f.action,param,config)//上传图片\n	     .then(response=>{\n	       f.onSuccess(response.data)\n	     })\n	     .catch(({err}) => {\n	       f.onError()\n	     })   \n	   })\n	   .catch(() => {\n	     f.onError()\n	   })\n	 },\n	 uploadImgSuccess(response, file, fileList) {\n		 // 缓存接口调用所需的文件路径\n		 console.log(''文件上传成功'')\n	 }，\n	 handleRemove(file, fileList) {\n		 // 更新缓存文件\n		 console.log(''文件删除'')\n	 }\n}\n\n\n```', 'Elementi中的upload组件的自定义上传的坑', 1589299200, 31, 0),
(28, 1, 'vue实例属性与方法', '# vue 实例属性 (_表示私有的属性vue内部用的)\n```\nvm._uid // 自增的id\nvm._isVue // 标示是vue对象，避免被observe\nvm._renderProxy // Proxy代理对象\nvm._self // 当前vm实例\n\nvm.$parent // 用于自定义子组件中，指向父组件的实例\nvm.$root // 指向根vm实例\nvm.$children // 当前组件的子组件实例数组\nvm.$refs \n\nvm._watcher = null\nvm._inactive = null\nvm._directInactive = false\nvm._isMounted = false // 标识是否已挂载\nvm._isDestroyed = false // 标识是否已销毁\nvm._isBeingDestroyed = false // 标识是否正在销毁\n\nvm._events // 当前元素上绑定的自定义事件\nvm._hasHookEvent // 标示是否有hook:开头的事件\n\nvm.$vnode // 当前自定义组件在父组件中的vnode，等同于vm.$options._parentVnode\nvm._vnode // 当前组件的vnode\nvm._staticTrees // 当前组件模板内分析出的静态内容的render函数数组\nvm.$el // 当前组件对应的根元素\n\nvm.$slots // 定义在父组件中的slots，是个对象键为name，值为响应的数组\nvm.$scopedSlots = emptyObject\n// 内部render函数使用的创建vnode的方法\nvm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n// 用户自定义render方法时，传入的参数\nvm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n\nvm._props // 被observe的存储props数据的对象\nvm._data // 被observe的存储data数据的对象\nvm._computedWatchers // 保存计算属性创建的watcher对象\n\n```\n\n2.实例属性(Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分)\n## 组件树\n### $parent：用来访问组件实例的父实例\n### $root: 用来访问当前组件树的根实例\n### $children:用来访问当前组件实例的直接子组件实例\n### $refs:用来访问v-ref指令的子组件\n\n## DOM\n### $el：用来挂载当前组件实例的dom元素\n### $els：用来访问$el元素中使用了v-el指令的DOM元素\n```\n<body>\n\n    <div id="app2">\n        {{ message }}\n    </div>\n</body>\n<script crossorigin="anonymous" integrity="sha384-g92AC94PwdsWZaIpD8bGSldDkIAgSf0X7tZ5Isd6rNXbjILE0EU6vrlj+gWPDMyY"\n    src="https://lib.baomitu.com/vue/2.6.11/vue.common.dev.js"></script>\n<script>\n\n\n    var vm2 = new Vue({\n        el: "#app2",\n        data: {\n            message: "I am message."\n        }\n    });\n    console.log(vm2.$el);          //vm2.$el === 原生js中document.getElementById("app2") \n    vm2.$el.style.color = "red";   //变成红色\n\n</script>\n```\n## 数据访问\n### $data：用来访问组件实例观察的数据对象\n### $options：用来访问组件实例化时的初始化选项对象\n## DOM方法的使用\n### $appendTo(elementOrSelector, callback)：将el所指的DOM元素插入目标元素\n### $before(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之前\n### $after(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之后\n### $remove(callback)：将el所指的DOM元素或片段从DOM中删除\n### $nextTick(callback)：用来在下一次DOM更新循环后执行指定的回调函数\n## EVENT方法的使用\n1.监听\n### $on(event, callback)：监听实例的自定义事件\n### $once(event, callback)：同上，但只能触发一次\n2.触发\n### $dispatch(event, args)：派发事件，先在当前实例触发，再沿父链一层层向上，对应的监听函数返回false停止\n### $broadcast(event, args)：广播事件，遍历当前实例的### $children，如果对应的监听函数返回false，就停止\n### $emit(event, args)：触发事件\n```\n\n<div id="ap2">\n    <p>{{ num }}</p>\n    <button @click="increase1"> add </button>\n</div>\n<button onclick="reduce2()"> reduce2 </button> <button onclick="offReduce()"> off reduce </button>\n<script>\n    var ap2 = new Vue({\n        el:"#ap2",\n        data:{\n            num:5\n        },\n        methods:{\n            increase1:function () {\n                this.num ++;\n            }\n        }\n    });\n    // .$on定义事件 .$once定义只触发一次的事件\n    ap2.$on("reduce",function (diff) {\n        ap2.num -= diff ;\n    });\n \n    // .$emit触发事件\n    function reduce2() {\n        ap2.$emit("reduce", 2);\n    }\n \n    // .$off解除事件 解除后，定义的reduce事件将不再执行\n    function offReduce() {\n        ap2.$off("reduce");\n    }\n</script>\n```\n# vue 实例方法\n## vm.$watch \n```\n\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: ''#example'',\n  data: data\n})\n \nvm.$data === data // -> true\nvm.$el === document.getElementById(''example'') // -> true\n \n// $watch 是一个实例方法\nvm.$watch(''a'', function (newVal, oldVal) {\n    \n})\n  // 这个回调将在 `vm.a`  改变后调用\n```\n## vm.$nextTick\n**\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上\n**\n```\n<div id="app">\n</div>\n<button onclick="vm.$destroy()">销毁实例 $destroy</button>\n<button onclick="vm.$forceUpdate()">刷新构造器 $forceUpdate</button>\n<button onclick="edit()">更新 $.nextTick(fn)</button>\n<script>\n    var Header = Vue.extend({\n        template:`<p>{{ message }}</p>`,\n        data:function () {\n            return {\n                message:"I am message"\n            }\n        },\n        updated:function () {\n            console.log("updated 更新之后");\n        },\n        destroyed:function () {\n            console.log("destroy 销毁之后");\n        }\n    });\n    var vm = new Header().$mount("#app");\n \n    function edit() {\n        vm.message = "new message";     //更新数据\n        vm.$nextTick(function () {      //更新完成后调用\n            console.log("更新完后，我被调用");\n        })\n}\n</script>\n```\n# vue自定义指令\n**vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：**\n```\n// 注册一个全局自定义指令 `v-focus`\nVue.directive(''focus'', {\n  // 当被绑定的元素插入到 DOM 中时……输入框自动聚焦\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n如果想注册局部指令，组件中也接受一个 directives 的选项\n```\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n然后你可以在模板中任何元素上使用新的 v-focus property，如下：\n```\n<input v-focus>\n```\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n```\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\ninserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n\nunbind：只调用一次，指令与元素解绑时调用。\n\n接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\nel：指令所绑定的元素，可以用来直接操作 DOM。\nbinding：一个对象，包含以下 property：\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\nvnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n```\n例子:\n```\n<div id="hook-arguments-example" v-demo:foo.a.b="message"></div>\nVue.directive(''demo'', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      ''name: ''       + s(binding.name) + ''<br>'' +\n      ''value: ''      + s(binding.value) + ''<br>'' +\n      ''expression: '' + s(binding.expression) + ''<br>'' +\n      ''argument: ''   + s(binding.arg) + ''<br>'' +\n      ''modifiers: ''  + s(binding.modifiers) + ''<br>'' +\n      ''vnode keys: '' + Object.keys(vnode).join('', '')\n  }\n})\n\nnew Vue({\n  el: ''#hook-arguments-example'',\n  data: {\n    message: ''hello!''\n  }\n})\n```\n```\nname: "demo"\nvalue: "hello!"\nexpression: "message"\nargument: "foo"\nmodifiers: {"a":true,"b":true}\nvnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder\n```\n\n## 补充动态指令参数\n**\n指令的参数可以是动态的。例如，在 v-mydirective:[argument]="value" 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。\n\n例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：\n**\n```\n<div id="baseexample">\n  <p>Scroll down the page</p>\n  <p v-pin="200">Stick me 200px from the top of the page</p>\n</div>\nVue.directive(''pin'', {\n  bind: function (el, binding, vnode) {\n    el.style.position = ''fixed''\n    el.style.top = binding.value + ''px''\n  }\n})\n\nnew Vue({\n  el: ''#baseexample''\n})\n```\n**这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新**\n```\n<div id="dynamicexample">\n  <h3>Scroll down inside this section ↓</h3>\n  <p v-pin:[direction]="200">I am pinned onto the page at 200px to the left.</p>\n</div>\nVue.directive(''pin'', {\n  bind: function (el, binding, vnode) {\n    el.style.position = ''fixed''\n    var s = (binding.arg == ''left'' ? ''left'' : ''top'')\n    el.style[s] = binding.value + ''px''\n  }\n})\n\nnew Vue({\n  el: ''#dynamicexample'',\n  data: function () {\n    return {\n      direction: ''left''\n    }\n  }\n})\n```', '```\n<body>\n    <div id="example"></div>\n</body>\n<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>\n<script>\n\n    var data = { a: 1 }\n    var vm = new Vue({\n        el: ''#example'',\n        data: data\n    })\n\n    vm.$data === data // -> true\n    vm.$el === document.getElementById(''example'') // -> true\n\n    // $watch 是一个实例方法\n    console.log(vm.$data)\n    vm.$watch(''a'', function (newVal, oldVal) {\n        console.log(newVal, oldVal)\n    })\n  // 这个回调将在 `vm.a`  改变后调用\n\n</script>\n```', 1589472000, 11, 0),
(29, 1, 'vue生命周期个人理解', '# 简述vue的生命周期 \n**首先会创建一个vue实例，这个实例对象身上，先执行了init方法（默认在vue组件里面执行的，有默认事件和生命周期函数），在init的过程中会先调用beforeCreate，然后在注射和发应性的时候再去调用created，然后这个时候才可以操作methods的方法和data里的数据。    ***          \n\n**当created之后，它会去判断这个instance(实例)是否有"el"  option，没有的话，它会在vue实例上挂载模板。如果有的话，就直接进行下一步，判断它是否有template option，有的话，它会把template解析成 render function，这是一个template编译的过程，结果是解析成render函数。**\n```\nrender(h){\n   return h (''div'',{},this.text) \n}\n```\nh就是vue里面的createElement方法\nreturn 返回一个createElement方法\n___\n**第一个参数是div标签  \n第二个参数传了一个对象，里面可以是props，或者事件之类的     \n第三个参数是div里面的内容**\n___\n\n使用render函数和template解析出来的结果是一样的  \n \n**render函数是发生在beforeMount和mounted之间的，这侧面也反应了在beforeMount的时候，$el还只是我们在html里面写的节点，到mounted的时候，它就把渲染的内容挂载dom节点上。这中间就是执行了render function的内容。 ***\n   \n其中我们在用vue脚手架开发的时候，写template模板时，都会经过vue-loader来处理，也就变成了render function，最终放到了vue-loader解析的文件里面，这样做目的是什么？             \n \n**其实解析template变成render function是一个非常耗时的过程，vue-loader帮助我们处理这些后，在vue页面上执行vue代码，效率会更高。beforeMount->render function -> mounted  挂载完毕之后，实例算是走完流程了。   ***\n\n后期钩子函数执行过程都要经过外部的触发才会执行。比如说数据的变化，会调用beforeUpdate，经过virtual DOM，updated才个更新完毕。组件被销毁，也会调用beforeDestory，Destoryed。      \n\n钩子函数理解：其实也算回调的一个概念，当系统执行到某处，检查是否有hook，有则回调。 直白来讲：每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。    \n\n补充:在开发过程中 ，Vue为我们提供了renderError方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们调试render里面的一些错误。\n```\nrenderError (h, err) {\n  return h(''div'', {}, err.stack)\n}\n```\n结合图理解：\n<img src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/11.png" />', '<img style="width:400px;height:400px"\nsrc="https://raw.githubusercontent.com/781650249/LLF_IMG/master/11.png" />', 1589385600, 22, 0),
(30, 1, '再也不怕面试官问你get&post区别了', '**一张图说明一切**\n<img  style="width:800px" src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/post%26get.png"/>\n\n补充:post 四种常见的提交数据的方式\n\n1.application/x-www-form-urlencoded   \n2.multipart/form-data     \n3.application/json   \n4.text/xml  \n[详见]:https://www.jianshu.com/p/d3c9b7ad1887', '简述get&post区别', 1558022400, 7, 0),
(31, 1, '深拷贝与浅拷贝', '___\n它们都只针对于引用类型，浅拷贝只复制指向对象的指针，而不复制对象本身，新旧对象还共享同一块内存。深拷贝会另外创造出一个一模一样的对象，新旧对象不共享内存，修改新对象不会影响到原对象。\n___\n区别：\n**浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；\n只有一层的话，可以采用object.assing({},被拷贝对象)**\n```\nlet obj1 = {\n   a: {\n     b: 1\n   },\n   c: 2\n}\nlet obj2 = Object.assign({},obj1)\nobj2.a.b = 3;\nobj2.c = 3\nconsole.log(obj1.a.b); // 3\nconsole.log(obj2.a.b); // 3\nconsole.log(obj1.c); // 2\nconsole.log(obj2.c); // 3\n```\n# 深拷贝:\n## 1.手动实现深拷贝\n```\nlet obj1 = {\n   a: 1,\n   b: 2\n}\nlet obj2 = {\n   a: obj1.a,\n   b: obj1.b\n}\nobj2.a = 3;\nalert(obj1.a); // 1\nalert(obj2.a); // 3\n```\n## 2.递归实现深拷贝\n```\nfunction deepCopy(obj1) {\n      var obj2 = Array.isArray(obj1) ? [] : {};\n      if (obj1 && typeof obj1 === "object") {\n        for (var i in obj1) {\n          if (obj1.hasOwnProperty(i)) {\n            // 如果子属性为引用数据类型，递归复制\n            if (obj1[i] && typeof obj1[i] === "object") {\n              obj2[i] = deepCopy(obj1[i]);\n            } else {\n              // 如果是基本数据类型，只是简单的复制\n              obj2[i] = obj1[i];\n            }\n          }\n        }\n      }\n      return obj2;\n    }\n    var obj1 = {\n      a: 1,\n      b: 2,\n      c: {\n        d: 3\n      }\n    }\n    var obj2 = deepCopy(obj1);\n    obj2.a = 3;\n    obj2.c.d = 4;\n    alert(obj1.a); // 1\n    alert(obj2.a); // 3\n    alert(obj1.c.d); // 3\n    alert(obj2.c.d); // 4\n```\n## 3.JSON.stringify() JSON.parse()实现深拷贝\n```\nfunction deepCopy(obj1){\n    let _obj = JSON.stringify(obj1);\n    let obj2 = JSON.parse(_obj);\n    return obj2;\n  }\n    var a = [1, [1, 2], 3, 4];\n    var b = deepCopy(a);\n    b[1][0] = 2;\n    alert(a); // 1,1,2,3,4\n    alert(b); // 2,2,2,3,4\n缺陷:它会抛弃对象的constructor，深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object；这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON；\nlet obj1 = {\n   fun:function(){\n      alert(123);\n   }\n}\nlet obj2 = JSON.parse(JSON.stringify(obj1));\nconsole.log(typeof obj1.fun); // function\nconsole.log(typeof obj2.fun); // undefined\n```\n## 4.lodash实现深拷贝\n```var _ = require(''lodash'');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);\n// false\n```\n## 5.jquery中$.extend实现深拷贝\n```\nvar $ = require(''jquery'');\nvar obj1 = {\n   a: 1,\n   b: {\n     f: {\n       g: 1\n     }\n   },\n   c: [1, 2, 3]\n};\nvar obj2 = $.extend(true, {}, obj1);\nconsole.log(obj1.b.f === obj2.b.f);  // false\n```\n', '深拷贝五种实现方式', 1589644800, 7, 0),
(32, 1, 'CSS加载会阻塞渲染吗', '可能大家都知道，js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？接下来，我就来对css加载对DOM树的解析和渲染的影响做一个测试。\n# 1.css加载会阻塞DOM树解析？\n```\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <title>css阻塞</title>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <style>\n      h1 {\n        color: red !important\n      }\n    </style>\n    <script>\n      function h () {\n        console.log(document.querySelectorAll(''h1''))\n      }\n      setTimeout(h, 0)\n    </script>\n    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">\n  </head>\n  <body>\n    <h1>这是红色的</h1>    \n  </body>\n</html>\n```\n测试结果：DOM树解析完成到了h1那里，而此时css还没加载完成，也就说明，css并不会阻塞DOM树的解析。\n# 2.css加载会阻塞DOM树渲染？\n由上面测试结果得，当css还没加载出来的时候，页面显示白屏，直到css加载完成之后，红色字体才显示出来，也就是说，下面的内容虽然解析了，但是并没有被渲染出来。所以，css加载会阻塞DOM树渲染。\n# css加载会阻塞JS执行吗？\n``` \n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <title>css阻塞</title>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <script>\n      console.log(''before css'')\n      var startDate = new Date()\n    </script>\n    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">\n  </head>\n  <body>\n    <h1>这是红色的</h1>\n    <script>\n      var endDate = new Date()\n      console.log(''after css'')  \n      console.log(''经过了'' + (endDate -startDate) + ''ms'')  //148ms  没有link css得话只有1ms\n    </script>\n  </body>\n</html>\n```\n结果：\n1. css加载不会阻塞DOM树的解析\n2. css加载会阻塞DOM树的渲染\n3. css加载会阻塞后面js语句的执行\n\n总结:\n1. 用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)\n2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)\n3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)\n4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)', '```\n1.css加载不会阻塞DOM树的解析   \n2.css加载会阻塞DOM树的渲染  \n3.css加载会阻塞后面js语句的执行\n```', 1589472000, 1, 0),
(33, 1, 'CSS实现滚动条听说过吗', '```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <title>css阻塞</title>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <style>\n        body {\n            /* 100vh 代表一个屏幕的高度  5px代表进度条的高度 */\n            background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%);\n            background-size: 100% calc(100% - 100vh + 5px);  \n            background-repeat: no-repeat;\n        }\n\n        body::after {\n            content: "";\n            position: fixed;\n            top: 5px;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: #fff;\n            z-index: -1;\n        }\n\n    </style>\n\n</head>\n\n<body>\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n\n   <div style="font-size: 20px; color:red">\n    dva 不仅是个第三方库 更是一个框架 整合地redux的相关内容让我们处理数据更加容易，\n    <br>    \n    实际上依赖了react react-router  react-redux  redux-saga redux  connect-react-router等\n    <br>    \n    redux 数据繁琐 router 繁琐的问题 \n    <br>    \n    1.dva 默认导出一个函数，通过调用这个函数 可以得到一个dva对象    <br>    \n    2.dva对象.router:路由方法，传入一个函数，该函数返回一个Reac节点，将来程序启动后，会自动渲染该节点    <br>     \n    3.dva对象 start 该方法启用dva应用程序可以认为启动的就是react程序，该函数传入一个选择器（''#app''） 用于选中页面的 某个dom元素 react将内容渲染到元素内部     <br>    \n    4.dva对象.model 用于定于一个模型 该模型可以认为redux的action reducer ,redux-saga的副作用的整合  整合成一个对象      <br>    \n     (1).namespace  命名空间 该属性是一个字符串 字符串的值会 被组为仓库中的属性值     <br>    \n     (2).state  仓库的默认状态      <br>    \n     (3).reducers  该属性配置一个对象，每个对象对应一个方法 方法的名字就是匹配的action类型 处理状态变化     <br>    \n     (4).effects  处理副作用 底层是redux-saga实现 该属性配置一个对象对象中每个方法均处理一个副作用 方法的名字就是匹配的action类型（远程请求 异步等等） 每个函数参数1是action，参数2是封装好的saga/effects对象，里面有很多saga指令方法    <br>    \n     (5).subscriptions   配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型中加入到仓库中运行     <br>    \n   <br>    \n   </div>\n</body>\n\n</html>\n\n```\n[参考张鑫旭] https://www.zhangxinxu.com/wordpress/2019/06/better-css-scroll-indicator/', '```\nbody::after {\n    content: "";\n    position: fixed;\n    top: 5px;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    background: #fff;\n    z-index: -1;\n}\n```', 1589731200, 2, 0),
(34, 1, '会怕面试官问你懒加载与预加载的区别了吗', '#  懒加载\n##  1.什么是懒加载\n懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式用户滚动到它们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。\n## 2.为什么要用懒加载\n**能提升用户的体验**，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。    \n**减少无效资源的加载**，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。   \n**防止并发加载的资源过多会阻塞js的加载**，影响网站的正常使用。   \n## 3.懒加载原理\n首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，\n当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。\n```\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Lazyload</title>\n    <style>\n      .image-item {\n	    display: block;\n	    margin-bottom: 50px;\n	    height: 200px;//一定记得设置图片高度\n	}\n    </style>\n</head>\n<body>\n<img src="" class="image-item" lazyload="true"  data-original="images/1.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/2.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/3.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/4.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/5.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/6.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/7.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/8.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/9.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/10.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/11.png"/>\n<img src="" class="image-item" lazyload="true"  data-original="images/12.png"/>\n<script>\nvar viewHeight =document.documentElement.clientHeight//获取可视区高度\nfunction lazyload(){\nvar eles=document.querySelectorAll（''img[data-original][lazyload]''）\nArray.prototype.forEach.call(eles,function(item,index){\nvar rect\nif(item.dataset.original==="")\n   return\nrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置\nif(rect.bottom>=0 && rect.top < viewHeight){\n!function(){\n  var img=new Image()\n  img.src=item.dataset.original\n  img.onload=function(){\n    item.src=img.src\n    }\nitem.removeAttribute（"data-original"）//移除属性，下次不再遍历\nitem.removeAttribute（"lazyload"）\n   }()\n  }\n })\n}\nlazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片\ndocument.addEventListener（"scroll"，lazyload)\n</script>\n</body>\n</html>\n```\n# 预加载\n## 1.什么是预加载\n资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。**预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。**\n## 2.为什么要用预加载\n在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。\n## 3.实现预加载的几种办法\n\n### 1.使用HTML标签\n```\n<img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/>\n```\n### 2.使用Image对象\n```\n<script src="./myPreload.js"></script>\n使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程\n```\n```\nvar xmlhttprequest=new XMLHttpRequest();\nxmlhttprequest.onreadystatechange=callback;\nxmlhttprequest.onprogress=progressCallback;\nxmlhttprequest.open("GET","http://image.baidu.com/mouse,jpg",true);\nxmlhttprequest.send();\nfunction callback(){\n  if(xmlhttprequest.readyState==4&& xmlhttprequest.status==200){\n    var responseText=xmlhttprequest.responseText;\n  }else{\n     console.log("Request was unsuccessful:"+xmlhttprequest.status);\n  }\n}\nfunction progressCallback(e){\ne=e || event;\nif(e.lengthComputable){\nconsole.log("Received"+e.loaded+"of"+e.total+"bytes")\n}\n}\n```\n\n\n### 使用PreloadJS库\nPreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。\n\n```\nvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域\nqueue.on("complete",handleComplete,this);\nqueue.loadManifest([\n{id:"myImage",src:"http://pic26.nipic.com/20121213/6168183  0044449030002.jpg"},\n{id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526  1931471581702.jpg"}\n]);\nfunction handleComplete(){\n  var image=queue.getResuLt("myImage");\n  document.body.appendChild(image);\n}\n\n```\n\n# 总结\n两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n', '两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力', 1589472000, 5, 0),
(35, 1, '彻底弄懂undefined&null的区别', '# Undefined\nundefined 是 Undefined 类型的值，表示未定义。   \n任何变量在赋值前都是 Undefined 类型，值为 undefined 。\n由于undefined 只是全局作用域下的一个属性（变量），并非关键字。undefined 属性的属性特性              \n**全局作用下的 undefined 不能被重写，而在函数作用域内是可以随意改写 undefined 的。**    \n```\nwindow.undefined = 1; // false\nfunction setUndefiend(){\n    let undefined = 1;\n    console.log(undefined); // 1\n    console.log(undefined === void 0); // false\n}\nsetUndefined();\n```\n## 1）定义了形参，没有传实参，显示undefined\n\n## 2）对象属性名不存在时，显示undefined\n\n## 3）函数没有写返回值，即没有写return，拿到的是undefined\n\n## 4）写了return，但没有赋值，拿到的是undefined\n\n\n# Null\n**Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。**\n## 1） 作为函数的参数，表示该函数的参数不是对象\n\n## 2） 作为对象原型链的终点\n```\nconsole.log(null==undefined);    //true  因为两者都默认转换成了false\nconsole.log(typeof undefined);    //"undefined"  \nconsole.log(typeof null);       //"object"  \nconsole.log(null===undefined);    //false   "==="表示绝对相等，null和undefined类型是不一样的，所以输出“false”\n转成number类型时 \nnull 默认转成 0\nundefined 默认转成 NaN\n```', '```\nconsole.log(null==undefined);    //true  因为两者都默认转换成了false\nconsole.log(typeof undefined);    //"undefined"  \nconsole.log(typeof null);       //"object"  \nconsole.log(null===undefined);    //false   "==="表示绝对相等，null和undefined类型是不一样的，所以输出“false”\n转成number类型时 \nnull 默认转成 0\nundefined 默认转成 NaN\n```', 1589126400, 10, 0),
(36, 1, '发布订阅模式，在工作中它的能量超乎你的想象', '**发布订阅模式，它其实是一种对象间一对多的依赖关系(不是综艺节目以一敌百那种)，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知**    \n\n用处：****广泛应用于异步编程中(替代了传递回调函数)\n对象之间松散耦合的编写代码****\n\n\n思路：    \n1.创建一个对象(缓存列表)              \n2.on方法用来把回调函数fn都加到缓存列表中    \n3.emit方法取到arguments里第一个当做key，根据key值去 \n4.执行对应缓存列表中的函数    \n5.remove方法可以根据key值取消订阅\n```\nlet corp = {};\n// 这次换成一个对象类型的缓存列表\ncorp.list = {};\n\ncorp.on = function(key, fn) {\n    // 如果对象中没有对应的key值\n    // 也就是说明没有订阅过\n    // 那就给key创建个缓存列表\n    if (!this.list[key]) {\n        this.list[key] = [];\n    }\n    // 把函数添加到对应key的缓存列表里\n    this.list[key].push(fn);\n};\ncorp.emit = function() {\n    // 第一个参数是对应的key值\n    // 直接用数组的shift方法取出\n    let key = [].shift.call(arguments),\n        fns = this.list[key];\n    // 如果缓存列表里没有函数就返回false\n    if (!fns || fns.length === 0) {\n        return false;\n    }\n    // 遍历key值对应的缓存列表\n    // 依次执行函数的方法\n    fns.forEach(fn => {\n        fn.apply(this, arguments);\n    });\n};\n\n// 测试用例\ncorp.on(''join'', (position, salary) => {\n    console.log(''你的职位是：'' + position);\n    console.log(''期望薪水：'' + salary);\n});\ncorp.on(''other'', (skill, hobby) => {\n    console.log(''你的技能有： '' + skill);\n    console.log(''爱好： '' + hobby);\n});\n\ncorp.emit(''join'', ''前端'', 10000);\ncorp.emit(''join'', ''后端'', 10000);\ncorp.emit(''other'', ''端茶和倒水'', ''足球'');\n/*\n    你的职位是：前端\n    期望薪水：10000\n    你的职位是：后端\n    期望薪水：10000\n    你的技能有： 端茶和倒水\n    爱好： 足球\n*/\n```\n\n通用版\n```\nlet event = {\n    list: {},\n    on(key, fn) {\n        if (!this.list[key]) {\n            this.list[key] = [];\n        }\n        this.list[key].push(fn);\n    },\n    emit() {\n        let key = [].shift.call(arguments),\n            fns = this.list[key];\n\n        if (!fns || fns.length === 0) {\n            return false;\n        }\n        fns.forEach(fn => {\n            fn.apply(this, arguments);\n        });\n    },\n    remove(key, fn) {\n        // 这回我们加入了取消订阅的方法\n        let fns = this.list[key];\n        // 如果缓存列表中没有函数，返回false\n        if (!fns) return false;\n        // 如果没有传对应函数的话\n        // 就会将key值对应缓存列表中的函数都清空掉\n        if (!fn) {\n            fns && (fns.length = 0);\n        } else {\n            // 遍历缓存列表，看看传入的fn与哪个函数相同\n            // 如果相同就直接从缓存列表中删掉即可\n            fns.forEach((cb, i) => {\n                if (cb === fn) {\n                    fns.splice(i, 1);\n                }\n            });\n        }\n    }\n};\n\nfunction cat() {\n    console.log(''一起喵喵喵'');\n}\nfunction dog() {\n    console.log(''一起旺旺旺'');\n}\n\nevent.on(''pet'', data => {\n    console.log(''接收数据'');\n    console.log(data);\n});\nevent.on(''pet'', cat);\nevent.on(''pet'', dog);\n// 取消dog方法的订阅\nevent.remove(''pet'', dog);\n// 发布\nevent.emit(''pet'', [''二哈'', ''波斯猫'']);\n/*\n    接收数据\n    [ ''二哈'', ''波斯猫'' ]\n    一起喵喵喵\n*/\n\n```', '```\nlet corp = {};   // 自定义一个公司对象\n// 这里放一个列表用来缓存回调函数\ncorp.list = [];\n// 去订阅事件\ncorp.on = function (fn) {\n    // 二话不说，直接把fn先存到列表中\n    this.list.push(fn);\n};\n// 发布事件\ncorp.emit = function () {\n    // 当发布的时候再把列表里存的函数依次执行\n    this.list.forEach(cb => {\n        cb.apply(this, arguments);\n    });\n};\n// 测试用例\ncorp.on(function (position, salary) {\n    console.log(''你的职位是：'' + position);\n    console.log(''期望薪水：'' + salary);\n});\ncorp.on(function(skill, hobby) {\n    console.log(''你的技能有： '' + skill);\n    console.log(''爱好： '' + hobby);\n});\n\ncorp.emit(''前端'', 10000);\ncorp.emit(''端茶和倒水'', ''足球'');\n/*\n    你的职位是：前端\n    期望薪水：10000\n    你的技能有： 前端\n    爱好： 10000\n    你的职位是：端茶和倒水\n    期望薪水：足球\n    你的技能有： 端茶和倒水\n    爱好： 足球\n*/ \n\n```', 1589731200, 4, 0);
INSERT INTO `article` (`Id`, `type_id`, `title`, `article_content`, `introduce`, `addTime`, `view_count`, `isTop`) VALUES
(37, 1, '手把手教你撸Promise', '# Promise\n来源:并不只是解决回调地狱，更是一种约束了js库的规范。\n```\nfunction getPermission(useName,callback){\n    \n    setTimeout(()=>{\n        var res = Math.random()\n        if(res<0.1){  \n            callback(''error'',null) //网络中断\n        }else if(res>0.5){\n            callback(null,false)  //没有权限\n        }else{\n            callback(null,true)  //有权限\n        }\n    },1000)\n\n\n}\n\n//文章\ngetPermission(''LLF'',function(err,result){\n    if(err){\n        //提示网络中断\n    } else if(result){\n        //有权限\n    }else{\n        //没有权限\n    }   \n})\n\n//留言\ngetPermission(''TL'',function(err,result){\n    if(err){\n        //提示网络中断\n    } else if(result){\n        //有权限\n    }else{\n        //没有权限\n    }   \n})\n很早之前，不同的库关于回调函数的参数千奇百怪，一下两个，一下三个，头晕眼花。在面对大型项目，几千个库的情况下，后来人们进行了一种规范，也就是node回调模式。\nnode回调模式\n1.所有回调函数不能作为属性出现\n2.所有回调函数必须作为函数最后的参数\n3.所有回调函数必须有两个参数，第一个参数表示错误，第二个参数表示结果\n再后来官方提出统一的规范:Promise诞生了\n```\n经过promise改造后得\n```\nfunction getPermission(useName){\n    return new Promise((resolve,reject){\n     setTimeout(()=>{\n        var res = Math.random()\n        if(res<0.1){  \n            reject(''网络连接中断'') //网络中断\n        }else if(res>0.5){\n            resolve(false)\n        }else{\n            resolve(true)\n        }\n    },1000)\n})\n\n}\n\n//文章\ngetPermission(''LLF'').then(result=>{\n   if(result){\n      console.log(''有权限发布文章'')\n    }else{\n     console.log("弹出消息，没有权限")\n    }\n},err=>{\n  console.log("错误："+ err)\n})\n\n```\n## 创建Promise\n首先来看看promise的用法，从名字可以看出它是个构造函数，所以我们得new它，得到一个Promise实例p，我们打印p看看\n```\nlet p = new Promise\nconsole.log(p) // TypeError: Promise resolver undefined is not a function\n```\n## 参数\n___\n报错信息告诉我们，Promise需要一些参数，这里需要一个函数（我们叫它执行器）作为参数，该函数有两个参数(resolve和reject)，这两个参数也是函数（由js引擎提供），我们可以在Promise内部调用，当异步操作成功时，调用resolve，否则reject \n___\n```\nlet p =new Promise(function(resolve, reject){\n    if(/* 异步操作成功 */){\n        resolve(data)\n    }else{\n        reject(err)\n    }\n})\n\n```\n## state\n现在我们需要知道一个重要概念，Promise是有“状态”的，分别是pending（等待态）、fulfilled（成功态）、rejected（失败态），pending可以转换为fulfilled或rejected，但fulfilled和rejected不可相互转化。\n\n## resolve/reject 方法\nresolve方法可以将pending转为fulfilled，reject方法可以将pending转为rejected。\n## then方法\n通过给Promise示例上的then方法传递两个函数作为参数，可以提供改变状态时的回调，第一个函数是成功的回调，第二个则是失败的回调。\n```\np.then(function(data){ // resolve方法会将参数传进成功的回调\n    console.log(data)  \n}, function(err){      // reject方法会将失败的信息传进失败的回调\n    console.log(err)\n})\n\nExample:\nlet p = new Promise(function(resolve, reject){\n    setTimeout(function(){\n        let num = Math.random()\n        if (num > 0.5) {\n            resolve(num)\n        }else{\n            reject(num)\n        }\n    }, 1000)\n})\np.then(function(num){\n    console.log(''大于0.5的数字：'', num)\n},function(num){\n    console.log(''小于等于0.5的数字'', num)\n})\n// 运行第一次：小于等于0.5的数字 0.166162996031475\n// 运行第二次：大于0.5的数字： 0.6591451548308984\n在Promise执行器中我们进行了一次异步操作，并在我们觉得合适的时候调用成功或失败的回调函数，并拿到了想要的数据以进行下一步操作\n```\n## 链式调用\n除此之外，每一个then方法都会返回一个新的Promise实例（不是原来那个），让then方法支持链式调用，并可以通过返回值将参数传递给下一个then\n```\np.then(function(num){\n    return num\n},function(num){\n    return num\n}).then(function(num){\n    console.log(''大于0.5的数字：'', num)\n},function(num){\n    console.log(''小于等于0.5的数字'', num)\n})\n```\n## catch方法\ncatch方法等同于.then(null, reject)，可以直接指定失败的回调（支持接收上一个then发生的错误）\n## Promise.all()\n这可能是个很有用的方法，它可以统一处理多个Promise\nPromise.all能将多个Promise实例包装成一个Promise实例\n```\nlet Promise1 = new Promise(function(resolve, reject){})\nlet Promise2 = new Promise(function(resolve, reject){})\nlet Promise3 = new Promise(function(resolve, reject){})\n\nlet p = Promise.all([Promise1, Promise2, Promise3])\n\np.then(funciton(){\n  // 三个都成功则成功  \n}, function(){\n  // 只要有失败，则失败 \n})\n```\n_____\n这个组合后的Promise实例和普通实例一样，有三种状态，这里有组成它的几个小Promise的状态决定 ：   \n1、当Promise1, Promise2, Promise3的状态都为成功态，则p为成功态；    \n2、当Promise1, Promise2, Promise3中有任意一个为失败态，则p为失败态；\n\nPromise.race()\n\n与all方法类似，也可以讲多个Promise实例包装成一个新的Promise实例\n不同的是，all时大Promise的状态由多个小Promise共同决定，而race时由第一个转变状态的小Promise的状态决定，第一个是成功态，则转成功态，第一个失败态，则转失败态\n\nPromise.resolve()\n\n可以生成一个成功的Promise\nPromise.resolve(''成功'')等同于new Promise(function(resolve){resolve(''成功'')})\n\nPromise.reject()\n\n可以生成一个失败的Promise\nPromise.reject(''出错了'')等同于new Promise((resolve, reject) => reject(''出错了''))\n____\n# Why Promise\n以jquery的ajax为例(@1.5.0版本以前，后来jquery也引入了Promise的概念)，看看从前我们是如何解决异步问题的。\n```\n$.get(''url'', {data: data}, function(result){\n    console.log(''成功'', result)// 成功的回调，result为异步拿到的数据\n});\n```\n想象一个场景，当我们需要发送多个异步请求，而请求之间相互关联相互依赖，没有请求1就不会有请求2，没有请求2就不会有请求3........\n```\n$.get(''url'', {data: data}, function(result1){\n    $.get(''url'', {data: result1}, function(result2){\n        $.get(''url'', {data: result2}, function(result3){\n            $.get(''url'', {data: result3}, function(result4){\n                ......\n                $.get(''url'', {data: resultn}, function(resultn+1){\n                    console.log(''成功'')\n                }\n            }\n        }\n    }\n});\n```\n**关键者来了，看看promise如何解决的**    \n1.txt的内容：\n```\n2.txt\n```\n2.txt的内容：\n```\n3.txt\n```\n3.txt的内容\n```\n完成\n```\n上代码:\n```\nlet readFile = require(''fs'').readFile; // 加载node内置模块fs 利用readFile方法异步访问文件\nfunction getFile(url){  // 创建一个读取文件方法\n    return new Promise(function(resolve, reject){  // 返回一个Promise对象\n        readFile(url, ''utf8'', function(err,data){  // 读取文件  \n            resolve(data)  // 调用成功的方法\n        })\n    })\n}\ngetFile(''1.txt'').then(function(data){  // then方法进行链式调用\n    console.log(data)  // 2.txt\n    return getFile(data)    //拿到了第一次的内容用来请求第二次\n}).then(function(data){\n    console.log(data)  // 3.txt\n    return getFile(data)  //拿到了第二次的内容用来请求第三次\n}).then(function(data){\n    console.log(data)  // 完成\n})\n\n```\n**通过创建一个读取函数返回一个Promise对象，再利用Promise自带的.then方法，将嵌套的异步代码弄得看起来像同步一样，这样的话，出现问题可以轻易的调试和修改。**\n# How Promise\n## 实现resolve、reject方法，then方法和状态机制\n根据使用方法我们可以知道，Promise是一个需要接受一个执行器的构造函数，执行器提供两个方法，内部有状态机制，原型链上有then方法。\n```\n// myPromise\nfunction Promise(executor){ //executor是一个执行器（函数）\n    let _this = this // 先缓存this以免后面指针混乱\n    _this.status = ''pending'' // 默认状态为等待态\n    _this.value = undefined // 成功时要传递给成功回调的数据，默认undefined\n    _this.reason = undefined // 失败时要传递给失败回调的原因，默认undefined\n    function resolve(value) { // 内置一个resolve方法，接收成功状态数据\n        // 上面说了，只有pending可以转为其他状态，所以这里要判断一下\n        if (_this.status === ''pending'') { \n            _this.status = ''resolved'' // 当调用resolve时要将状态改为成功态\n            _this.value = value // 保存成功时传进来的数据\n        }\n    }\n    function reject(reason) { // 内置一个reject方法，失败状态时接收原因\n        if (_this.status === ''pending'') { // 和resolve同理\n            _this.status = ''rejected'' // 转为失败态\n            _this.reason = reason // 保存失败原因\n        }\n    }\n    executor(resolve, reject) // 执行执行器函数，并将两个方法传入\n}\n// then方法接收两个参数，分别是成功和失败的回调，这里我们命名为onFulfilled和onRjected\nPromise.prototype.then = function(onFulfilled, onRjected){\n    let _this = this;   // 依然缓存this\n    if(_this.status === ''resolved''){  // 判断当前Promise的状态\n        onFulfilled(_this.value)  // 如果是成功态，当然是要执行用户传递的成功回调，并把数据传进去\n    }\n    if(_this.status === ''rejected''){ // 同理\n        onRjected(_this.reason)\n    }\n}\nmodule.exports = Promise  // 导出模块，否则别的文件没法使用\n```\n测试一下：\n```\nlet Promise = require(''./myPromise'')  // 引入模块\nlet p = new Promise(function(resolve, reject){\n  resolve(''test'')\n})\np.then(function(data){\n  console.log(''成功'', data)\n},function(err){\n  console.log(''失败'', err)\n})\n// 成功 test\n\n```\n```\nlet Promise = require(''./myPromise'')  // 引入模块\nlet p = new Promise(function(resolve, reject){\n  reject(''test'')\n})\np.then(function(data){\n  console.log(''成功'', data)\n},function(err){\n  console.log(''失败'', err)\n})\n// 失败 test\n```\n```\nlet p = new Promise(function(resolve, reject){\n  setTimeout(function(){\n    resolve(100)  \n  }, 1000)\n})\np.then(function(data){\n  console.log(''成功'', data)\n},function(err){\n  console.log(''失败'', err)\n})\n// 不会输出任何代码\n```\n___\n原因是我们在then函数中只对成功态和失败态进行了判断，而实例被new时，执行器中的代码会立即执行，但setTimeout中的代码将稍后执行，也就是说，then方法执行时，Promise的状态没有被改变依然是pending态，所以我们要对pending态也做判断，而由于代码可能是异步的，那么我们就要想办法把回调函数进行缓存，并且，then方法是可以多次使用的，所以要能存多个回调，那么这里我们用一个数组。\n___\n## 实现异步\n在实例上挂两个参数\n```\n_this.onResolvedCallbacks = []; // 存放then成功的回调\n_this.onRejectedCallbacks = []; // 存放then失败的回调\n\n```\nthen方法加一个pending的判断\n```\nif(_this.status === ''pending''){\n    // 每一次then时，如果是等待态，就把回调函数push进数组中，什么时候改变状态什么时候再执行\n    _this.onResolvedCallbacks.push(function(){ // 这里用一个函数包起来，是为了后面加入新的逻辑进去\n        onFulfilled(_this.value)\n    })\n    _this.onRejectedCallbacks.push(function(){ // 同理\n        onRjected(_this.reason)\n    })\n}\n```\n下一步要分别在resolve和reject方法里加入执行数组中存放的函数的方法，修改一下上面的resolve和reject方法\n```\nfunction resolve(value) {\n    if (_this.status === ''pending'') { \n        _this.status = ''resolved''\n        _this.value = value\n        _this.onResolvedCallbacks.forEach(function(fn){ // 当成功的函数被调用时，之前缓存的回调函数会被一一调用\n            fn()\n        })\n    }\n}\nfunction reject(reason) {\n    if (_this.status === ''pending'') {\n        _this.status = ''rejected''\n        _this.reason = reason\n        _this.onRejectedCallbacks.forEach(function(fn){// 当失败的函数被调用时，之前缓存的回调函数会被一一调用\n            fn()\n        })\n    }\n}\n\n```\n现在可以执行异步任务了，也可以多次then了，一个穷人版Promise就完成了，\n## 处理错误\n上面的代码虽然能用，但经不起考验，真正的Promise如果在实例中抛出错误，应该走reject:\n```\nnew Promise(function(resolve, reject){\n  throw new Error(''错误'')\n}).then(function(){\n    \n},function(err){\n  console.log(''错误:'', err)  \n})\n// 错误: Error: 错误\n\n```\n我们实现一下，思路很简单，在执行器执行时进行try catch\n```\ntry{\n    executor(resolve, reject)        \n}catch(e){ // 如果捕获发生异常，直接调失败，并把参数穿进去\n    reject(e)\n}\n\n```\n还有其它方法自行研究\n```\n穷人版 promise\nfunction myPromise(exector) {\n    let _this = this;\n    _this.status = ''pending''\n    _this.value = undefined\n    _this.reason = undefined\n    _this.onResolveCallbacks = []\n    _this.onRejectedCallbacks = []\n    function resolve(value) {\n        if (_this.status === ''pending'') {\n            _this.status = ''resolved''\n            _this.value = value\n            _this.onResolveCallbacks.push(function () {\n                onFulfilled(_this.value)\n            })\n            _this.onResolveCallbacks.forEach(function (fn) {\n                fn()\n            })\n        }\n    }\n    function reject(reason) {\n        if (_this.status === ''pending'') {\n            _this.status = ''rejected''\n            _this.reason = reason\n            _this.onRejectedCallbacks.push(function () {\n                onRejected(_this.reason)\n            })\n            _this.onRejectedCallbacks.forEach(function (fn) {\n                fn()\n            })\n        }\n    }\n    try {\n        exector(resolve, reject)  //将这两个方法传到执行器函数中\n    } catch (e) {\n        reject(e)\n    }\n}\n\nPromise.prototype.then = function (onFulfilled, onRejected) {\n    let _this = this;\n    if (_this.status === ''resolved'') {\n        onFulfilled(_this.value)\n    }\n    if (_this.status === ''rejected'') {\n        onRejected(_this.reason)\n    }\n}\n\nmodule.exports = Promise\n```', '```\n// myPromise\nfunction Promise(executor){ //executor是一个执行器（函数）\n    let _this = this // 先缓存this以免后面指针混乱\n    _this.status = ''pending'' // 默认状态为等待态\n    _this.value = undefined // 成功时要传递给成功回调的数据，默认undefined\n    _this.reason = undefined // 失败时要传递给失败回调的原因，默认undefined\n    function resolve(value) { // 内置一个resolve方法，接收成功状态数据\n        // 上面说了，只有pending可以转为其他状态，所以这里要判断一下\n        if (_this.status === ''pending'') { \n            _this.status = ''resolved'' // 当调用resolve时要将状态改为成功态\n            _this.value = value // 保存成功时传进来的数据\n        }\n    }\n    function reject(reason) { // 内置一个reject方法，失败状态时接收原因\n        if (_this.status === ''pending'') { // 和resolve同理\n            _this.status = ''rejected'' // 转为失败态\n            _this.reason = reason // 保存失败原因\n        }\n    }\n    executor(resolve, reject) // 执行执行器函数，并将两个方法传入\n}\n// then方法接收两个参数，分别是成功和失败的回调，这里我们命名为onFulfilled和onRjected\nPromise.prototype.then = function(onFulfilled, onRjected){\n    let _this = this;   // 依然缓存this\n    if(_this.status === ''resolved''){  // 判断当前Promise的状态\n        onFulfilled(_this.value)  // 如果是成功态，当然是要执行用户传递的成功回调，并把数据传进去\n    }\n    if(_this.status === ''rejected''){ // 同理\n        onRjected(_this.reason)\n    }\n}\nmodule.exports = Promise  // 导出模块，否则别的文件没法使用\n```', 1589817600, 11, 0),
(38, 1, '手撕“穷人版VUE“', '___\n1.编译模块  \n2.虚拟节点模块    \n3.渲染模块     \n4.数据响应模块      \n5.vue构造函数模块\n___\n\n# 编译模块\n提供一个compile函数，将一个模板文本和环境对象编译成一个结果\n```\n//compile.js\n\nfunction getFragments(template) {\n    var match = template.match(/{{[^}]+}}/g);\n    return match || [];      //[''{{name}}'',''{{age}}'']\n}\n\nfunction getValue(fragment, envObj) {\n    var exp = fragment.replace("{{", "").replace("}}", "");\n    var props = exp.split(''.'')  //存在obj.name 将表达式分割成一个属性数组\n    var obj = envObj;\n    for (var i = 0; i < props.length; i++) {\n        obj = obj[props[i]]   //循坏拿到对象最里面的值\n    }\n    return obj;\n}\n\n//根据模板和环境对象，得到编译结果\nexport default function compile(template, envObj) {\n    //提前模板中的 {{xxx}}\n    var frag = getFragments(template);\n    var result = template\n    for (var i = 0; i < frag.length; i++) {\n        var frags = frag[i];\n        result = result.replace(frags, getValue(frags, envObj))\n    } \n    return result\n}\n```\n```\n//index.html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n    <script type="module">\n        import compile from ''./vue/compile.js''\n        var result = compile(''姓名{{name}},年龄：{{age}},居住省份:{{addr.province}}'', {\n            name: ''monica'',\n            age: 16,\n            addr: {\n                province: "黑龙江",\n                city: ''哈尔滨''\n            }\n        })\n        console.log(result)  // 姓名monica,年龄：16,居住省份:黑龙江\n    </script>\n</body>\n\n</html>\n```\n# 虚拟节点模块\n提供一个函数createVNode,根据提供的真实DOM，构建一个虚拟DOM树\n```\n\nfunction VNode(realDom, template) {\n    this.realDom = realDom;\n    this.template = template;\n    this.children = []\n}\n\nexport default function createVNode(realDom) {\n    var root = new VNode(realDom, '''')\n    if (realDom.nodeType === Node.TEXT_NODE) {\n        //判断真实节点是否是文本节点\n        //如果是文本节点，需要记录文本节点的值到虚拟节点\n        root.template = realDom.nodeValue;\n    } else {\n        // 不是文本节点，循坏真实节点的子节点\n        for (var i = 0; i < realDom.childNodes.length; i++) {\n            var childRealNode = realDom.childNodes[i]\n            var vNode = createVNode(childRealNode)\n            root.children.push(vNode)\n        }\n    }\n    return root;\n}\n```\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<div id="app">\n    <p>姓名: {{name}}</p>\n    <p>年龄: {{age}}</p>\n</div>\n\n<body>\n    <script type="module">\n        import createVNode from ''./vue/vnode.js''\n        var vNode = createVNode(document.getElementById(''app''))\n        console.log(vNode)\n        /*\n        VNode {realDom: div#app, template: "", children: Array(5)}\n        children: (5) [VNode, VNode, VNode, VNode, VNode]\n        realDom: div#app\n        template: ""\n        __proto__: Object\n        */\n    </script>\n</body>\n\n</html>\n```\n# 渲染模块\n用于提取虚拟节点中的文本节点，将其模板编译结果设置到真实dom中，对虚拟节点的子节点也做同样的操作。\n```\n//render.js\n\nimport compile from ''./compile.js''\n//渲染一个虚拟节点（将文本节点的虚拟节点进行编译）\nexport default function render(vnode, envObj) {\n    if (vnode.realDom.nodeType === Node.TEXT_NODE) {\n        vnode.realDom.nodeValue = compile(vnode.template, envObj)  //将vnode.template编译将编译结果设置到realDom.nodevalue中\n    } else {\n        for (var i = 0; i < vnode.children.length; i++) {\n            var childNode = vnode.children[i]\n            render(childNode, envObj)\n        }\n    }\n}\n```\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<div id="app">\n    <p>姓名: {{name}}</p>\n    <p>年龄: {{age}}</p>\n    <dl>\n        <dd>省份:{{addr.province}}</dd>\n        <dd>城市:{{addr.city}}</dd>\n    </dl>\n</div>\n\n<body>\n    <script type="module">\n        import render from ''./vue/render.js''\n        import createVNode from ''./vue/vnode.js''\n        var vNode = createVNode(document.getElementById(''app''))\n        render(vNode, {\n            name: ''monica'',\n            age: 18,\n            addr: {\n                province: ''黑龙江'',\n                city: ''哈尔滨''\n            }\n        })\n    </script>\n</body>\n\n</html>\n\n/* \n姓名: monica\n\n年龄: 18\n\n省份:黑龙江\n\n城市:哈尔滨\n*/\n\n```\n\n\n\n\n\n\n\n# 数据响应模块\n主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据更改时，执行某个回调函数。\n```\n//dataResponsive.js\nfunction proxyProp(originalObj, targetObj, prop, callback) {\n    if (typeof originalObj[prop] === ''object'') {\n        var newTarget = {}  //新的要代理该属性的对象\n        createResponsive(originalObj[prop], newTarget, callback);\n        Object.defineProperty(targetObj, prop, {\n            get: function () {\n                return newTarget\n            },\n            set: function (value) {\n                originObj[prop] = value;\n                newTarget = value;\n                callback && callback(prop)\n            }\n        })\n    } else {\n        Object.defineProperty(targetObj, prop, {\n            get: function () {\n                return originalObj[prop]\n            },\n            set: function (value) {\n                originalObj[prop] = value;\n                callback && callback(prop)\n            }\n        })\n    }\n\n}\n\n\n\n//将原始对象的所有属性，提取到代理对象中\n//原始对象 代理对象  当代理对象的属性被赋值的时候，需要运行的回调函数\n\nexport default function createResponsive(originalObj, targetObj, callback) {\n    for (var prop in originalObj) {\n        proxyProp(originalObj, targetObj, prop, callback)\n    }\n}\n\n/* \noriginObj:\n{\n            name: ''monica'',\n            age: 18,\n            addr: {\n                province: ''黑龙江'',\n                city: ''哈尔滨''\n            }\n}\ntargetObj:\n{\n            代理name\n            代理age\n            代理newTarget\n \n}\nnewTarget: \n{\n           代理province\n           代理city\n} \n*/\n```\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<div id="app">\n    <p>姓名: {{name}}</p>\n    <p>年龄: {{age}}</p>\n    <dl>\n        <dd>省份:{{addr.province}}</dd>\n        <dd>城市:{{addr.city}}</dd>\n    </dl>\n</div>\n\n<body>\n    <script type="module">\n        import createResponsive from ''./vue/dataResponsive.js''\n        var originObj = {\n            name: ''monica'',\n            age: 18,\n            addr: {\n                province: ''黑龙江'',\n                city: ''哈尔滨''\n            }\n        }\n        window.targetObj = {}\n        createResponsive(originObj, targetObj,\n            function (prop) {\n                console.log(prop + ''属性发生变化'')\n            })\n\n      \n\n    </script>\n</body>\n\n</html>\n```\n# Vue构造函数模块\n通过vue构造函数可以创建一个Vue实例，在创建过程中，完成以下操作:\n## 1.保存el和data配置\n## 2.根据el创建虚拟节点\n## 3.将data中的数据附加到代理对象-vue实例中\n```\n//Vue.js\n\nimport createVNode from "./vnode.js";\nimport createResponsive from "./dataResponsive.js";\nimport render from ''./render.js''\n\n\nexport default function Vue(options) {\n    //保存el和data的配置\n    this.$el = options && options.el;\n    this.$data = options && options.data;\n    //根据el创建虚拟节点\n    this.$vnode = createVNode(document.querySelector(this.$el))\n    //将data中的数据附加到代理对象—— vue实例中\n    var that = this\n    createResponsive(this.$data, this, function () {\n        //重新渲染\n        that.render()\n    })\n    this.render() //初始渲染    \n}\n\nVue.prototype.render = function () {\n    render(this.$vnode, this)\n}\n```\n```\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<div id="app">\n    <p>姓名: {{name}}</p>\n    <p>年龄: {{age}}</p>\n    <button onClick="vm.age++">增加年龄</button>\n    <dl>\n        <dd>省份:{{attr.province}}</dd>\n        <dd>城市:{{attr.city}}</dd>\n    </dl>\n    修改省份: <input type="text" oninput="vm.attr.province = this.value" />\n</div>\n\n<body>\n    <script type="module">\n          import Vue from ''./vue/Vue.js''\n        window.vm = new Vue({\n            el: ''#app'',\n            data: {\n                name: ''monica'',\n                age: 16,\n                attr: {\n                    province: ''黑龙江'',\n                    city: ''哈尔滨''\n                }\n            }\n        })\n\n\n    </script>\n</body>\n\n</html>\n```\n<img src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/LLF_IMG/vue.png" />', '```\n1.编译模块\n2.虚拟节点模块\n3.渲染模块\n4.数据响应模块\n5.vue构造函数模块\n```', 1589904000, 19, 0),
(39, 1, '浅谈js的内存泄露', '什么是内存泄漏？     \n**泄漏说白了就是本该被回收的内存因为一些异常没有被回收掉，而一直存在于内存中占用内存， 虽然说js有垃圾自动回收机制，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被正常回收**\n# 1.对象直接赋值\n```\nvar a = {\n  name: ''test1'',\n  age: 1\n};\nvar b = a;\na = {\n  name: ''test2'',\n  age: 2\n};\n \nconsole.log(a); // {name: ''test2'', age: 2}\nconsole.log(b); // {name: ''test1'', age: 1}\n```\n上面的代码中，我们首先声明了变量a并初始化a的值为一个对象，然后我们将a的值赋值给了变量b，然后又给了a一个新的值，按照对象引用的理解b应该等于新赋值的a，其实不然我们第一次声明a并赋值的时候系统为我们申请了一块儿内存并将地址指向了a，然后将a赋值给b，系统将指向a的内存地址同时指向了b，接着a重新赋值切断了之前赋值时a与指向的内存地址之间的联系，又重新申请了一块儿内存指向了a，而原来指向a的那块儿内存还是在内存中，所以b还是之前a的值。所以在编写代码的过程中应该尽量避免对对象变量直接赋值。\n# 2.意外的全局变量\n```\nfunction test(){\na = ''test''\n}\n相当于\nfunction test(){\nwindow.a = ''test\n}\n闭包:\n(function(){\nfor(let i =0;i<10;i++){\n\n}\n}())\n```\n本来test函数调用完毕后，函数内部变量占用的内存是会被回收的，但是由于注册的是一个全局变量，导致a变量所占用的内存不会被回收。为了防止这种错误的发生，我们可以在js代码头部位置加上''use strict'';以严格模式来编写代码\n# 3.定时器setInterval setTimeout                     \n定时器 setInterval或者setTimeout在不需要的时候没有被clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，造成内存泄漏，比如我们在react的componentDidMount中使用了定时器，那么在componentWillUnmount中一定要记得清除定时器，不然就会造成内存泄漏。清除的方式如下：\n```\nclearTimeout(t);\nclearInterval(t);\n```\n# 4.给DOM元素添加的属性是一个对象的引用\n```\nvar obj = {}; \ndocument.querySelector(''selector'').property = obj;\n```\n在页面卸载的时候，设置DOM元素的属性值设置为null，好让内存回收\n```\nwindow.onunload = function() {\n   document.querySelector(''selector'').property = null;\n}\n```\n# 5.事件绑定及移除\n比如在react中，如果我们在componentDidMount中监听了某个节点的某个事件\n```\nnode.addEventListener(''event'',func,false)\n```\n必须要在componentwillDidMount中移除\n```\nnode.removeEventListener(''event'',func,false)\n```\n总结:\n**上面说了这么多，有些朋友可能会觉得，现在电脑配置都还不错，内存泄漏点也没啥事情，这个想法也没啥太大问题，些许的问题在电脑上确实没有太大的感知，但是如果是运行在手机上呢？微信小程序中呢？那么可能导致的结果就是我们辛辛苦苦开发的应用直接闪退，所以我觉得我们还是应该重视这些问题，一点点的内存占用也是占用了，当工程越来越庞大的时候，这些小问题就会被累积起来，然后拖垮我们的程序。**\n\n常见内存泄漏例子：\n```\nfunction showBiBao() {\n    for (var i = 0; i < 5; i++) {\n      setTimeout( function timer() {\n          console.log(i);   // 5 5 5 5 5 \n      }, 1000 );\n    }\n    console.log(i)\n}\n// 会输出什么\nshowBiBao()\n```\n1.for循环5次，那么应该设定了5个定时器，这个没错\n2.setTimeout等待for循环执行完成后立即调用定时器\n3.setTimeout被放在了队列的数据结构中（for循环），等待上下文的代码运行后再执行定时器，此时运行定时器，变量i已经变成了5（此时5个定时器的i都是5），所以输出全是5\n\n___\n1.需要把每个定时器访问的变量独立起来，改变i的作用域\n2.可以用闭包实现这个目的：在for循环里写一个闭包   \n3.show code\n___\n```\nfunction showListNumber() {\n    for(var i = 0; i < 5; i++) {\n        (function(i) {\n            setTimeout(function timerr() {\n                console.log(i)\n            }, 1000)\n        })(i)\n    }\n    console.log(i)\n}\nshowListNumber()\n```\n或者\n```\nfunction useLetChange() {\n    for (let i = 0; i < 5; i++) {\n      setTimeout( function timer() {\n          console.log(i);\n      }, 1000 );\n    }\n}\nuseLetChange()\n```', '```\nfunction useLetChange() {\n    for (let i = 0; i < 5; i++) {\n      setTimeout( function timer() {\n          console.log(i);\n      }, 1000 );\n    }\n}\nuseLetChange()\n```', 1589904000, 6, 0),
(40, 1, '聊一聊js中的原型和原型链', '# 1.原型和原型链\n- 所有对象都是通过```new 函数```创建\n- 所有的函数也是对象\n  - 函数中可以有属性  typeOf Number  //function  \n     Number.isNaN\n- 所有对象都是引用类型\n```\n  function test(){\n            return {\n\n            }\n        }\n\n        var obj = new test();\n        obj.__proto__ === test.prototype     //false\n        obj.__proto__ === object.prototype     //false\n\n   function test(){\n      \n        }\n\n        var obj = new test();\n        obj.__proto__ === test.prototype     //true\n```\n<img style="width:600px" src="https://raw.githubusercontent.com/781650249/JS_Code-review/master/10.%20JS%E8%BF%9B%E9%98%B6/1.%20%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%9B%BE%E4%BE%8B/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E9%80%9A%E8%BF%87new%20%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%9A%84.jpg" />     \n                                  \n结合图来看：普通对象通过new 一个函数来创建，普通函数也是对象，通过一个New Function函数来创建，Function函数是内存中一开始就存在的。\n\n# 2.原型 prototype\n- 所有函数都有一个属性：prototype，称之为函数原型,普通对象{}没有prototype\nObject.prototype\nNumber.prototype\nArray.prototype\n- 默认情况下，prototype是一个普通的Object对象\n\n- 默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身。\n<img style="width:600px" src="https://raw.githubusercontent.com/781650249/JS_Code-review/master/10.%20JS%E8%BF%9B%E9%98%B6/1.%20%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%9B%BE%E4%BE%8B/%E5%8E%9F%E5%9E%8B%E4%B8%AD%E7%9A%84constructor%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB.jpg"/>       \n\n\n## 隐式原型proto\n\n- 所有的对象都有一个属性：```__proto__```，称之为隐式原型。 \n\n- 默认情况下，隐式原型指向创建该对象的函数的原型。\n```\n    function test(){\n            return {\n\n            }\n        }\n    var obj =new test()\n\n    obj.__proto === test.prototype //true\n   test.prototype.constructor === test  //true\n```\n- 当访问一个对象的成员时：\n\n  1. 看该对象自身是否拥有该成员，如果有直接使用\n  2. 在原型链中依次查找是否拥有该成员，如果有直接使用\n\n```\n      function User(name,age){\n            this.name = name ;\n            this.age = age;\n            this.Sayhello=function(){\n                console.log(111)\n            }\n        }\n        var u1 = new User(''abc'',11)\n        var u2 = new User(''bcd'',12 )\n        console.log(u1.Sayhello === u2.Sayhello)  //false\n\n     将共有方法提到原型上去\n         function User(name,age){\n            this.name = name ;\n            this.age = age;\n        }\n        User.prototype.Sayhello = function(){\n            console.log(111)\n        }\n\n        var u1 = new User(''abc'',11)\n        var u2 = new User(''bcd'',12 )\n        console.log(u1.Sayhello === u2.Sayhello)  //true\n       console.log(u1.__proto__.Sayhello === u2.__proto__.Sayhello)  //true\n这也就解释了数组中有很多的方法\nArray.prototype === [].__proto__  //true  \nconcat: ƒ concat()\nconstructor: ƒ Array()\ncopyWithin: ƒ copyWithin()\nentries: ƒ entries()\nevery: ƒ every()\n__proto__: Object\n```\n**数组的原型上添加自定义方法**                 \n**// Array.prototype.abc =2121**   \n这样无论是哪个数组都有abc这个属性  \n  **[].abc     //2121**  \n**[1212121,211221].abc   //2121**\n\n//字符串原型上添加自定义方法\n将字符串中的首字母大写\n```\n    //正则匹配\n       String.prototype.camel = function () {\n            return this.replace(/\\b(\\w)(\\w*)\\b/g, function ($, $1, $2) {\n                return $1.toUpperCase() + $2;\n            }).replace(/\\s/g,"")\n        }\n//''nidnee wew de2e2''.camel()\n// "Nidnee Wew De2e2"\n```\n**猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。**\n## 原型链\n```\n\n       function A(){\n\n       }\n\n       var A = new Function();\n       A.__proto__ === Function.prototype  //true\n       \n       \n```\n<img  style="width:600px" src="https://raw.githubusercontent.com/781650249/JS_Code-review/master/10.%20JS%E8%BF%9B%E9%98%B6/1.%20%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%9B%BE%E4%BE%8B/%E9%93%BE%E6%9D%A1%E7%9A%84%E5%85%A8%E8%B2%8C.jpg" />\n\n```\n     //EP1:   \n        function A() {\n\n        }\n        var obj = new A()\n        \n        obj.toString = function () {\n             return ''abc''\n        }\n        同理 也可以在函数原型上添加toString() 作用一样\n       A.prototype.toString = function(){\n             return ''abc''\n       }\n        obj.toString() //abc\n        // 强行用原型__proto__上的toString()来调用\n        Object.prototype.toString(obj)    //[ Object Object ]\n\n     \n     //EP:2\n        var arr = [1,2,3,4]\n        arr.toString()  // ''1,2,3,4''\n        // 强行用原型__proto__上的toString()来调用 \n        Object.prototype.toString(arr)  //[ Object Array ]\n\n    // 总结:\n        // 自定义对象的 tostring()方法,如果有自己的tostring方法，就不会沿着原型__proto__往上找了   强行调用Object原型上的toString()方法\n```\n三道面试题\n```\nEP1:\nvar F = function () {}\nObject.prototype.a = function () {}\nFunction.prototype.b = function () {}\n\nvar f = new F();\n\nconsole.log(f.a, f.b, F.a, F.b);\n// fn    undefined    fn    fn\n```\n```\nEP2:\nfunction A() {}\nfunction B(a) {\n    this.a = a;\n}\nfunction C(a) {\n    if (a) {\n        this.a = a;\n    }\n}\nA.prototype.a = 1;\nB.prototype.a = 1;\nC.prototype.a = 1;\n\nconsole.log(new A().a); //1\nconsole.log(new B().a); //undefined\nconsole.log(new C(2).a); //2\n```\n```\nEP3:\nfunction User() {}\nUser.prototype.sayHello = function() {}\n\nvar u1 = new User();\nvar u2 = new User();\n\nconsole.log(u1.sayHello === u2.sayHello); //true\nconsole.log(User.prototype.constructor); //User Function\nconsole.log(User.prototype === Function.prototype); // false\nconsole.log(User.__proto__ === Function.prototype); // true\nconsole.log(User.__proto__ === Function.__proto__); // true\nconsole.log(u1.__proto__ === u2.__proto__);  // true\nconsole.log(u1.__proto__ === User.__proto__); // false\nconsole.log(Function.__proto__ === Object.__proto__); // true\nconsole.log(Function.prototype.__proto__ === Object.prototype.__proto__); // false\nconsole.log(Function.prototype.__proto__ === Object.prototype); // true\n```', '<img  style="width:600px" src="https://raw.githubusercontent.com/781650249/JS_Code-review/master/10.%20JS%E8%BF%9B%E9%98%B6/1.%20%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%9B%BE%E4%BE%8B/%E9%93%BE%E6%9D%A1%E7%9A%84%E5%85%A8%E8%B2%8C.jpg" />', 1589990400, 29, 0),
(41, 1, 'React生命周期(v16.0之前)', '\n# 1.初始化(Init)\n类的构造方法( constructor() ),Test类继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。\nsuper(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件，功子组件读取(组件中props只读不可变，state可变)。\n而constructor()用来做一些组件的初始化工作，如定义this.state的初始内容\n```\nimport React, { Component } from ''react'';\nclass Test extends Component {\n  constructor(props) {\n    super(props);\n  }\n}\n```\n# 2.挂载(Mounting)阶段\n此阶段分为componentWillMount，render，componentDidMount三个时期。\n* componentWillMount:               \n在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。\n* render:\n根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。\n* componentDidMount:                  \n组件挂载到DOM后调用，且只会被调用一次                  \n                                                                      \n# 3.更新(update)阶段\nsetState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。<https://www.cnblogs.com/penghuwan/p/6707254.html>详见shouldComponentUpdate\n造成组件更新有两类（三种）情况：\n*1.父组件重新render\na. 直接使用,每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。\n```\nclass Child extends Component {\n   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n        if(nextProps.someThings === this.props.someThings){\n          return false\n        }\n    }\n    render() {\n        return <div>{this.props.someThings}</div>\n    }\n}\n```\nb.在componentWillReceiveProps方法中，将props转换成自己的state\n```\nclass Child extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            someThings: props.someThings\n        };\n    }\n    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n        this.setState({someThings: nextProps.someThings});\n    }\n    render() {\n        return <div>{this.state.someThings}</div>\n    }\n}\n```\n官网描述:在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。                                        \n是因为componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了。\n*2.组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。\n```\nclass Child extends Component {\n   constructor(props) {\n        super(props);\n        this.state = {\n          someThings:1\n        }\n   }\n   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n        if(nextStates.someThings === this.state.someThings){\n          return false\n        }\n    }\n\n   handleClick = () => { // 虽然调用了setState ，但state并无变化\n        const preSomeThings = this.state.someThings\n         this.setState({\n            someThings: preSomeThings\n         })\n   }\n\n    render() {\n        return <div onClick = {this.handleClick}>{this.state.someThings}</div>\n    }\n}\n```\n此阶段分为componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate\n*componentWillReceiveProps(nextProps)\n此方法只调用于props引起的组件更新过程中，响应 Props 变化之后进行更新的唯一方式，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render\n*shouldComponentUpdate(nextProps, nextState)\n此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。\n\nps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。\n\n如果shouldComponentUpdate 返回false，那就一定不用rerender(重新渲染 )这个组件了，组件的React elements(React 元素) 也不用去比对。 但是如果shouldComponentUpdate 返回true，会进行组件的React elements比对，如果相同，则不用rerender这个组件，如果不同，会调用render函数进行rerender。\n* componentWillUpdate(nextProps, nextState)\n此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。\n*render\nrender方法在上文讲过，这边只是重新调用。\n*componentDidUpdate(prevProps, prevState)\n此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state\n# 4.卸载(unMounted)阶段\n* componentWillUnmount\n此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。\n<img  style="width:650px" src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" />', '<img  style="width:650px" src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" />', 1590681600, 5, 0),
(42, 1, 'React生命周期(v16.0之后)', '<img style="width:600px" src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/16.04%E5%90%8E.webp"  />\n\n\n\n**相对于16.0版本之前，废弃了componentwillMount,componentwillReceiveProps,compoentwillUpdate,这三个生命周期函数，\n在16.0版本之前 react 是同步渲染的，而16.0版本之后，是通过异步渲染的方式进行渲染，在render函数之前所有函数都有可能被执行多次。\n1.componentwillMount 移除原因   这个函数在render之前,但是在这里发起ajax请求，不过多快得到结果也赶不上首次render，数据都在render之后到达\n2.componentwillReveiveProps 移除原因  props变化会产生副作用，此函数可能在一次更新中被调用多次，应该使用componentDidUpdate ，保证每次更新只调用一次。\n3.componentwillupdate  移除原因  本来是配合componentDidupdate 分别获取render前后的视图状态，随着react更新  react被分割多次完成，导致 componentwillupdate和componentDidUpdate 执行前后间隔很长时间，很难追踪Bug**\n\n新增两个函数:               \n**1.static getDerivedStateFromProps\n2.getSnapshotBeforeUpdate**\n\n分为三个阶段： 1.挂载 2.更新 3.卸载                    \n# 1.挂载 \n\n***constructor              \ngetDerivedStateFromProps             \nrender             \ncomponentDidMount***\n\n\n**constructor**            \n组件的构造函数，第一个被执行。如果在组件中没有显示定义它，则会拥有一个默认的构造函数。如果我们显示定义构造函数，则必须在构造函数第一行执行 super(props)，否则我们无法在构造函数里拿到 this              \n在构造函数中，我们一般会做两件事：   \n1.初始化 state           \n2.对自定义方法进行 this 的绑定\n```\nconstructor(props) {\n    super(props);\n    this.state = {\n      width,\n      height: ''atuo'',\n    }\n\n    this.handleChange1 = this.handleChange1.bind(this);\n    this.handleChange2 = this.handleChange2.bind(this);\n}\n\n```\n\n**getDerivedStateFromProps**\n```\n//static getDerivedStateFromProps(nextProps, prevState)\n\nclass Example extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    //根据 nextProps 和 prevState 计算出预期的状态改变，返回结果会被送给 setState\n    // ...\n  }\n}\n\n```\n新的 getDerivedStateFromProps 是一个静态函数，所以不能在这函数里使用 this，简单来说就是一个纯函数。也表明了 React 团队想通过这种方式防止开发者滥用这个生命周期函数。每当父组件引发当前组件的渲染过程时，getDerivedStateFromProps 会被调用，这样我们有一个机会可以根据新的 props 和当前的 state 来调整新的 state。\n__这个函数会返回一个对象用来更新当前的 state，如果不需要更新可以返回 null。这个生命周期函数用得比较少，主要用于在重新渲染期间手动对滚动位置进行设置等场景中。该函数会在挂载时，在更新时接收到新的 props，调用了 setState 和 forceUpdate 时被调用___\n取代了componentWillReceiveProps和componentDidUpdate，父组件引发渲染可能要根据 props 更新 state 的需要而设立的。             \n**render**            \n当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：           \n原生的 DOM，如 div\nReact 组件                     \n数组或 Fragment                        \nPortals（插槽）                    \n字符串和数字，被渲染成文本节点                 \nBoolean 或 null，不会渲染任何东西              \nrender() 函数应该是一个纯函数，里面只做一件事，就是返回需要渲染的东西，不应该包含其它的业务逻辑，如数据请求，对于这些业务逻辑请移到 componentDidMount 和 componentDidUpdate 中。\n\n **componentDidMount**\ncomponentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。 \n  这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅\n你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。\n请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理\n\n# 2.更新\ngetDerivedStateFromProps\nshouldComponentUpdate\nrender \ngetSnapshotBeforeUpdate\ncomponentDidUpdate\n\n**getDerivedStateFromProps**              \n该函数会在挂载时，在更新时接收到新的 props，调用了 setState 和 forceUpdate 时被调用\n\n**shouldComponentUpdate**\n```\nshouldComponentUpdate(nextProps, nextState)\n它有两个参数，根据此函数的返回值来判断是否进行重新渲染，true 表示重新渲染，false 表示不重新渲染，默认返回 true。注意，首次渲染或者当我们调用 forceUpdate 时并不会触发此方法。此方法仅用于性能优化。\n因为默认是返回 true，也就是只要接收到新的属性和调用了 setState 都会触发重新的渲染，这会带来一定的性能问题，所以我们需要将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较来决定是否返回 false，来减少重新渲染，以优化性能。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。\n但是官方提倡我们使用内置的 PureComponent 来减少重新渲染的次数，而不是手动编写 shouldComponentUpdate 代码。PureComponent 内部实现了对 props 和 state 进行浅层比较。\n```\n\n**getSnapshotBeforeUpdate**\n```\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n\ngetSnapshotBeforeUpdate 生命周期方法在 render 之后，在更新之前（如：更新 DOM 之前）被调用。给了一个机会去获取 DOM 信息，计算得到并返回一个 snapshot，这个 snapshot 会作为 componentDidUpdate 的第三个参数传入。如果你不想要返回值，请返回 null，不写的话控制台会有警告。\n并且，这个方法一定要和 componentDidUpdate 一起使用，否则控制台也会有警告。getSnapshotBeforeUpdate 与 componentDidUpdate 一起，这个新的生命周期涵盖过时的 UNSAFE_componentWillUpdate 的所有用例。         \n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  console.log(''#enter getSnapshotBeforeUpdate'');\n  return ''foo'';\n}\n\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n  console.log(''#enter componentDidUpdate snapshot = '', snapshot);\n}\n这个函数一般用在重新渲染过程中手动保留滚动位置等情况下\n```\n\n**componentDidUpdate**\n\n```\ncomponentDidUpdate(prevProps, prevState, snapshot)\ncomponentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。在这个函数里我们可以操作 DOM，和发起服务器请求，还可以 setState，但是注意一定要用 if 语句控制，否则会导致无限循环。\n\ncomponentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n# 3.卸载         \n**componentWillUnmount**\ncomponentWillUnmount() 会在组件卸载及销毁之前直接调用。我们可以在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。注意不要在这个函数里调用 setState()，因为组件不会重新渲染了。', '<img style="width:600px" src="https://raw.githubusercontent.com/781650249/LLF_IMG/master/16.04%E5%90%8E.webp"  />', 1592841600, 2, 0),
(43, 1, 'React写一个移动的小球', '```\nimport ReactDOM from ''react-dom'';\nimport React, { Component } from ''react''\nimport { getRandam } from ''./utils/getRandam''\n\n//一个小球的 初始状态   位置\nclass Ball extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            top: props.top || 0,\n            left: props.left || 0,\n            xSpeed: props.xSpeed,\n            ySpeed: props.ySpeed\n        }\n\n        const duration = 10\n        setInterval(() => {\n            const xDis = this.state.xSpeed * duration / 1000;\n            const yDis = this.state.ySpeed * duration / 1000;\n            let newLeft = this.state.left + xDis;\n            let newTop = this.state.top + yDis;\n            if (newLeft < 0) {\n                newLeft = 0;\n                this.setState({\n                    xSpeed: -this.state.xSpeed\n                })\n            } else if (newLeft >= document.documentElement.clientWidth - 100) {\n                newLeft = document.documentElement.clientWidth - 100;\n                this.setState({\n                    xSpeed: -this.state.xSpeed\n                })\n            }\n\n            if (newTop < 0) {\n                newTop = 0;\n                this.setState({\n                    ySpeed: -this.state.ySpeed\n                })\n            } else if (newTop >= document.documentElement.clientHeight - 100) {\n                newTop = document.documentElement.clientHeight - 100\n                this.setState({\n                    ySpeed: - this.state.ySpeed\n                })\n            }\n\n            this.setState({\n                left: newLeft,\n                top: newTop\n            })\n\n        }, duration)\n\n    }\n\n    render() {\n        return (\n            <div className="ball" style={{\n                width: ''100px'',\n                height: ''100px'',\n                left: this.state.left,\n                top: this.state.top,\n                background: this.props.bg || ''#f40'',\n                borderRadius: ''50%'',\n                position: ''absolute''\n            }}>\n\n            </div >\n        )\n\n    }\n\n}\n\n\nclass BallList extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            ballsInfo: []\n        }\n        const timer = setInterval(() => {\n            let info = {\n                left: getRandam(0, document.documentElement.clientWidth - 100),\n                top: getRandam(0, document.documentElement.clientHeight - 100),\n                xSpeed: getRandam(50, 500),\n                ySpeed: getRandam(50, 500),\n                bg: `rgb(${getRandam(0, 255)},${getRandam(0, 255)},${getRandam(0, 255)}`\n            }\n            this.setState({\n                ballsInfo: [...this.state.ballsInfo, info]\n            })\n            if (this.state.ballsInfo.length === 10) {\n                clearInterval(timer)\n            }\n        }, 1000)\n\n    }\n\n    render() {\n        const balls = this.state.ballsInfo.map((item, i) => {\n            console.log(item)\n            return (\n                <Ball key={i} {...item}></Ball>\n            )\n        })\n        return (\n            <>\n                {balls}\n            </>\n        )\n    }\n}\n\nReactDOM.render(<BallList />, document.getElementById(''root''));\n\n```', '```\n        const duration = 10\n        setInterval(() => {\n            const xDis = this.state.xSpeed * duration / 1000;\n            const yDis = this.state.ySpeed * duration / 1000;\n            let newLeft = this.state.left + xDis;\n            let newTop = this.state.top + yDis;\n            if (newLeft < 0) {\n                newLeft = 0;\n                this.setState({\n                    xSpeed: -this.state.xSpeed\n                })\n            } else if (newLeft >= document.documentElement.clientWidth - 100) {\n                newLeft = document.documentElement.clientWidth - 100;\n                this.setState({\n                    xSpeed: -this.state.xSpeed\n                })\n            }\n\n            if (newTop < 0) {\n                newTop = 0;\n                this.setState({\n                    ySpeed: -this.state.ySpeed\n                })\n            } else if (newTop >= document.documentElement.clientHeight - 100) {\n                newTop = document.documentElement.clientHeight - 100\n                this.setState({\n                    ySpeed: - this.state.ySpeed\n                })\n            }\n\n            this.setState({\n                left: newLeft,\n                top: newTop\n            })\n\n        }, duration)\n```', 1591459200, 6, 0),
(44, 1, 'React实现自定义蒙层', '```\nimport React, { Component } from ''react''\nimport reactDom from ''react-dom'';\n\nfunction Modal(props) {\n    console.log(props)\n    var defaultProps = {\n        bg: ''rgba(0,0,0,.5)''\n    }\n    var datas = Object.assign({}, defaultProps, props)\n    return (\n        <div className="modal" onClick={(e) => {\n            if (e.target.className === ''modal'') {\n                datas.onClose()\n            }\n        }}\n            style={{\n                background: datas.bg,\n                width: ''100%'',\n                height: ''100%'',\n                position: "fixed",\n                left: 0,\n                top: 0\n            }}>\n            <div>\n                {datas.children}\n            </div>\n        </div>\n    )\n}\n\n\nclass Test extends Component {\n\n    state = {\n        showModal: false\n    }\n\n    hideModal = (e) => {\n        this.setState({\n            showModal: false\n        })\n    }\n\n    showModal = () => {\n        this.setState({\n            showModal: true\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3159856553,1527464792&fm=27&gp=0.jpg" alt="" />\n                {\n                    this.state.showModal ? (<Modal onClose={this.hideModal}>\n                        <div style={{\n                            background: ''#fff''\n                        }}>\n                            <h1>asdfasfasfasfasdfasdf</h1>\n                            <button onClick={this.hideModal}>关闭蒙层</button>\n                        </div>\n\n                    </Modal>) : null\n                }\n                <button onClick={this.showModal}>显示朦层</button>\n            </div>\n        )\n    }\n}\n\n\nreactDom.render(<Test />, document.getElementById(''root''))\n\n\n\n```', '```\n    render() {\n        return (\n            <div>\n                <img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3159856553,1527464792&fm=27&gp=0.jpg" alt="" />\n                {\n                    this.state.showModal ? (<Modal onClose={this.hideModal}>\n                        <div style={{\n                            background: ''#fff''\n                        }}>\n                            <h1>asdfasfasfasfasdfasdf</h1>\n                            <button onClick={this.hideModal}>关闭蒙层</button>\n                        </div>\n\n                    </Modal>) : null\n                }\n                <button onClick={this.showModal}>显示朦层</button>\n            </div>\n        )\n    }\n```', 1591545600, 6, 0),
(45, 1, '聊聊递归的应用', '递归：本质就是自己调用自己              \n写一个递归的步骤：   \n#### 1.  找出口\n递归一定有一个出口，锁定出口，保证不会死循环\n递归条件，符合递归条件，自己调用自己。\n#### 2. 递归条件            \n符合递归条件，自己调用自己。\n应用举例：\n  ```\n深度克隆\n var obj1= [''a'',''b'',{c:3}]\n\n var arr2 = [''a'',''b'',["c",1]]\n\nfunction deepClone(obj1) {\n    var obj2 = Array.isArray(obj1) ? [] : {}\n    if (obj1 && typeof obj1 === "object") {\n        for (var i in obj1) {\n            if (obj1.hasOwnProperty(i)) {\n                if (obj1[i] && typeof obj1[i] === ''object'') {\n                    obj2[i] = deepClone(obj1[i])\n                } else {\n                    obj2[i] = obj1[i]\n                }\n            }\n        }\n    }\n    return obj2;\n}\n简写：\nvar deepClone = function (obj) {\n    if (typeof obj !== ''object'') return;\n    var newObj = obj instanceof Array ? [] : {}\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === ''object'' ? deepClone(obj[key]) : obj[key];\n        }\n    }\n    return newObj\n}\n\nvar aaa = deepClone(c)\n\nconst obj2 = deepClone(arr2)\nconsole.log(obj2)   //[''a'',''b'',["c",1]]\n\n ```\n```\n嵌套数组扁平化\n\nvar arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n解法1\nArray.prototype.flat = function() {\n    var arr = [];\n    this.forEach((item,idx) => {\n        if(Array.isArray(item)) {\n            arr = arr.concat(item.flat()); //递归去处理数组元素\n        } else {\n            arr.push(item)   //非数组直接push进去\n        }\n    })\n    return arr;   //递归出口\n}\n解法2\narr.prototype.flat = function() {\n    this.toString().split('','').map(item=> +item )\n}\n\n\n```\n\n```\n爬楼梯问题\n有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？\n解析:                                               \n这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。\nfunction cStairs(n) {\n    if(n === 1 || n === 2) {\n        return 1;\n    } else {\n        return cStairs(n-1) + cStairs(n-2)\n    }\n}\n\n```\n```\n二分查找\n设定区间,low和high\n找出口： 找到target，返回target；否则寻找，当前次序没有找到，把区间缩小后递归\nfunction binaryFind(arr,target,low = 0,high = arr.length - 1) {\n    const n = Math.floor((low+high) /2);\n    const cur = arr[n];\n    if(cur === target) {\n        return `找到了${target},在第${n+1}个`;\n    } else if(cur > target) {\n        return binaryFind(arr,target,low, n-1);\n    } else if (cur < target) {\n        return binaryFind(arr,target,n+1,high);\n    }\n    return -1;\n}\n\n```', '```\nvar deepClone = function (obj) {\n    if (typeof obj !== ''object'') return;\n    var newObj = obj instanceof Array ? [] : {}\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === ''object'' ? deepClone(obj[key]) : obj[key];\n        }\n    }\n    return newObj\n}\n\n```', 1593878400, 4, 0);

-- --------------------------------------------------------

--
-- 表的结构 `type`
--

CREATE TABLE IF NOT EXISTS `type` (
  `Id` int(11) NOT NULL,
  `typeName` varchar(255) NOT NULL,
  `orderNum` int(11) NOT NULL,
  `icon` char(255) DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `type`
--

INSERT INTO `type` (`Id`, `typeName`, `orderNum`, `icon`) VALUES
(1, '实用技术', 1, 'youtube'),
(2, '项目开发', 2, 'message'),
(3, '日常采坑', 3, 'smile');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE IF NOT EXISTS `user` (
  `id` int(11) NOT NULL,
  `userName` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`id`, `userName`, `password`) VALUES
(1, 'llf', '1234');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `artcomment`
--
ALTER TABLE `artcomment`
  ADD PRIMARY KEY (`id`) USING BTREE;

--
-- Indexes for table `article`
--
ALTER TABLE `article`
  ADD PRIMARY KEY (`Id`) USING BTREE;

--
-- Indexes for table `type`
--
ALTER TABLE `type`
  ADD PRIMARY KEY (`Id`) USING BTREE;

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`id`) USING BTREE;

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `artcomment`
--
ALTER TABLE `artcomment`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=45;
--
-- AUTO_INCREMENT for table `article`
--
ALTER TABLE `article`
  MODIFY `Id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=46;
--
-- AUTO_INCREMENT for table `type`
--
ALTER TABLE `type`
  MODIFY `Id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=4;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
